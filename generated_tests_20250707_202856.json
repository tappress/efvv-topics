{
  "generation_date": "2025-07-07T20:45:57.524775",
  "total_topics": 122,
  "successful_generations": 118,
  "tests": {
    "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ|Основи структури даних і алгоритми|Поняття алгоритму. Визначення його часової та просторової (за обсягом пам'яті) складності": {
      "question": "Яка з наведених характеристик найточніше описує O-нотацію в аналізі алгоритмів?",
      "options": [
        "Верхня межа часової складності алгоритму в найгіршому випадку.",
        "Середній час виконання алгоритму для всіх можливих вхідних даних.",
        "Точний час виконання алгоритму для конкретного вхідного набору даних.",
        "Кількість пам'яті, яку використовує алгоритм у найкращому випадку."
      ],
      "correct": 0,
      "explanation": "O-нотація використовується для опису асимптотичної поведінки алгоритмів, зокрема верхньої межі часової складності в найгіршому випадку. Вона не дає точного часу виконання, а лише показує, як зростає час виконання алгоритму при збільшенні розміру вхідних даних.",
      "difficulty": "B",
      "section": "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ",
      "subsection": "Основи структури даних і алгоритми",
      "topic": "Поняття алгоритму. Визначення його часової та просторової (за обсягом пам'яті) складності"
    },
    "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ|Основи структури даних і алгоритми|Поняття абстрактного типу даних. Абстрактні типи даних: стеки, списки, вектори, словники, множини, мультимножини, черги, черги з пріоритетами": {
      "question": "Який принцип роботи використовується в структурі даних 'стек'?",
      "options": [
        "Round Robin",
        "FIFO (First In, First Out)",
        "Priority-based",
        "LIFO (Last In, First Out)"
      ],
      "correct": 3,
      "explanation": "Стек використовує принцип LIFO (Last In, First Out), що означає, що останній елемент, доданий до стеку, буде першим вилученим. Це відбувається через операції push (додавання елемента на вершину стеку) та pop (вилучення елемента з вершини стеку).",
      "difficulty": "B",
      "section": "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ",
      "subsection": "Основи структури даних і алгоритми",
      "topic": "Поняття абстрактного типу даних. Абстрактні типи даних: стеки, списки, вектори, словники, множини, мультимножини, черги, черги з пріоритетами"
    },
    "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ|Основи структури даних і алгоритми|Кортежі, множини, словники, одно- та двобічнозв'язні списки. Реалізація абстрактних типів даних з оцінюванням складності операцій": {
      "question": "Яка з наведених структур даних має найкращу (O(1)) складність операції вставки на початок?",
      "options": [
        "Двозв'язний список",
        "Однозв'язний список",
        "Черга",
        "Динамічний масив"
      ],
      "correct": 0,
      "explanation": "Двозв'язний список має складність O(1) для вставки на початок, оскільки він зберігає посилання як на наступний, так і на попередній елемент, що дозволяє швидко оновити зв'язки. Однозв'язний список також має O(1) для вставки на початок, але двозв'язний список більш універсальний. Динамічний масив має O(n) складність через необхідність зсуву елементів, а черга не призначена для вставки на початок.",
      "difficulty": "B",
      "section": "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ",
      "subsection": "Основи структури даних і алгоритми",
      "topic": "Кортежі, множини, словники, одно- та двобічнозв'язні списки. Реалізація абстрактних типів даних з оцінюванням складності операцій"
    },
    "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ|Основи структури даних і алгоритми|Базові алгоритми та їх складність: пошук, сортування (прості сортування вибором, вставками, обмінами та удосконалені сортування деревом, сортування Шелла, швидке сортування)": {
      "question": "Який алгоритм сортування має найгіршу часову складність у найгіршому випадку серед наведених?",
      "options": [
        "Heap sort",
        "Quick sort (при неправильному виборі опорного елемента)",
        "Bubble sort",
        "Merge sort"
      ],
      "correct": 2,
      "explanation": "Bubble sort має найгіршу часову складність O(n²) у всіх випадках, на відміну від інших алгоритмів. Merge sort та Heap sort мають O(n log n) навіть у найгіршому випадку, а Quick sort може досягати O(n²) лише при невдалому виборі опору (наприклад, якщо завжди береться перший елемент для вже відсортованого масиву).",
      "difficulty": "B",
      "section": "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ",
      "subsection": "Основи структури даних і алгоритми",
      "topic": "Базові алгоритми та їх складність: пошук, сортування (прості сортування вибором, вставками, обмінами та удосконалені сортування деревом, сортування Шелла, швидке сортування)"
    },
    "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ|Основи структури даних і алгоритми|Алгоритми на графах та їх складність: пошук в ширину і глибину; пошук зв'язних компонентів; побудова кістякового дерева; побудова найкоротших шляхів з виділеної вершини; побудова найкоротших шляхів між двома вершинами": {
      "question": "Який алгоритм знаходження найкоротшого шляху між усіма парами вершин у графі з вагами ребер використовує динамічне програмування?",
      "options": [
        "Алгоритм Флойда-Воршелла",
        "Алгоритм Крускала",
        "Алгоритм Прима",
        "Алгоритм Дійкстри"
      ],
      "correct": 0,
      "explanation": "Алгоритм Флойда-Воршелла використовує динамічне програмування для знаходження найкоротших шляхів між усіма парами вершин у графі. Він працює з графами, що можуть містити ребра з від'ємними вагами (але без від'ємних циклів), і має часову складність O(n³), де n — кількість вершин. Інші варіанти не відповідають умові: алгоритм Дійкстри знаходить найкоротші шляхи з однієї вершини, а алгоритми Крускала та Прима використовуються для побудови кістякового дерева.",
      "difficulty": "B",
      "section": "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ",
      "subsection": "Основи структури даних і алгоритми",
      "topic": "Алгоритми на графах та їх складність: пошук в ширину і глибину; пошук зв'язних компонентів; побудова кістякового дерева; побудова найкоротших шляхів з виділеної вершини; побудова найкоротших шляхів між двома вершинами"
    },
    "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ|Стратегії розроблення алгоритмів|Стратегія «розділяй та володарюй» та приклади застосування": {
      "question": "Який з наведених алгоритмів НЕ є прикладом стратегії «розділяй та володарюй»?",
      "options": [
        "Сортування бульбашкою",
        "Quick sort",
        "Merge sort",
        "Бінарний пошук"
      ],
      "correct": 0,
      "explanation": "Сортування бульбашкою не використовує стратегію «розділяй та володарюй». Він працює шляхом послідовного порівняння та обміну сусідніх елементів. На відміну від нього, Merge sort, Quick sort та бінарний пошук базуються на принципі поділу задачі на менші підзадачі, їх вирішенні та об'єднанні результатів.",
      "difficulty": "B",
      "section": "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ",
      "subsection": "Стратегії розроблення алгоритмів",
      "topic": "Стратегія «розділяй та володарюй» та приклади застосування"
    },
    "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ|Стратегії розроблення алгоритмів|Стратегія балансування та приклади застосування": {
      "question": "Який з наведених алгоритмів є прикладом жадібного алгоритму?",
      "options": [
        "Алгоритм Дейкстри для знаходження найкоротшого шляху в графі.",
        "Алгоритм бінарного пошуку.",
        "Алгоритм швидкого сортування (Quick Sort).",
        "Алгоритм сортування злиттям."
      ],
      "correct": 0,
      "explanation": "Алгоритм Дейкстри є прикладом жадібного алгоритму, оскільки на кожному кроці він обирає найкоротший шлях з поточної вершини, не зважаючи на можливі довші шляхи в майбутньому. Це відповідає принципу жадібності – локально оптимальний вибір на кожному етапі.",
      "difficulty": "B",
      "section": "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ",
      "subsection": "Стратегії розроблення алгоритмів",
      "topic": "Стратегія балансування та приклади застосування"
    },
    "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ|Стратегії розроблення алгоритмів|Динамічне програмування та приклади застосування": {
      "question": "Яка з наведених задач є класичним прикладом використання динамічного програмування?",
      "options": [
        "Сортування масиву методом бульбашки.",
        "Пошук елемента у відсортованому масиві.",
        "Обчислення чисел Фібоначчі.",
        "Обчислення факторіалу числа."
      ],
      "correct": 2,
      "explanation": "Обчислення чисел Фібоначчі є класичним прикладом динамічного програмування, оскільки воно використовує підпроблеми (попередні числа Фібоначчі) для ефективного обчислення наступних значень, уникнення повторних обчислень. Інші варіанти не використовують динамічне програмування.",
      "difficulty": "B",
      "section": "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ",
      "subsection": "Стратегії розроблення алгоритмів",
      "topic": "Динамічне програмування та приклади застосування"
    },
    "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ|Стратегії розроблення алгоритмів|Оцінювання складності алгоритму під час застосування кожної стратегії": {
      "question": "Яке рекурентне співвідношення описує складність алгоритму, розробленого за стратегією 'розділяй і володарюй', якщо задача розділяється на дві підзадачі розміром n/2, а об’єднання результатів має складність O(n)?",
      "options": [
        "T(n) = T(n/2) + O(n)",
        "T(n) = T(n-1) + T(n-2) + O(n)",
        "T(n) = 2T(n-1) + O(n)",
        "T(n) = 2T(n/2) + O(n)"
      ],
      "correct": 3,
      "explanation": "Правильна відповідь — T(n) = 2T(n/2) + O(n), оскільки вона відображає розділення задачі на дві підзадачі розміром n/2 (2T(n/2)) та лінійну складність об’єднання результатів (O(n)). Це типовий випадок для таких алгоритмів, як сортування злиттям або швидке сортування.",
      "difficulty": "B",
      "section": "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ",
      "subsection": "Стратегії розроблення алгоритмів",
      "topic": "Оцінювання складності алгоритму під час застосування кожної стратегії"
    },
    "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ|Моделі обчислень|Imperativний та декларативний підходи до програмування": {
      "question": "Яка основна відмінність між процедурним та функціональним програмуванням?",
      "options": [
        "Функціональне програмування вимагає менше пам'яті, ніж процедурне.",
        "Процедурне програмування завжди працює швидше за функціональне.",
        "Процедурне програмування не підтримує рекурсію, на відміну від функціонального.",
        "Процедурне програмування використовує мутабельність та побічні ефекти, а функціональне — імутабельність та чисті функції."
      ],
      "correct": 3,
      "explanation": "Основна відмінність полягає в підходах до обробки даних. Процедурне програмування базується на послідовності інструкцій із зміною стану (мутабельність) та побічними ефектами, тоді як функціональне програмування використовує імутабельність (незмінність даних) та чисті функції (без побічних ефектів). Інші варіанти є неправильними: швидкість залежить від реалізації, обидва підходи можуть використовувати рекурсію, а витрати пам'яті не є визначальною характеристикою.",
      "difficulty": "B",
      "section": "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ",
      "subsection": "Моделі обчислень",
      "topic": "Imperativний та декларативний підходи до програмування"
    },
    "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ|Моделі обчислень|Розв'язні, напіврозв'язні та нерозв'язні проблеми. Проблема зупинки": {
      "question": "Яка з наведених проблем є нерозв'язною згідно з теоремою Тьюринга?",
      "options": [
        "Сортування масиву за зростанням.",
        "Проблема зупинки (halting problem).",
        "Знаходження найкоротшого шляху у графі.",
        "Перевірка числа на простоту."
      ],
      "correct": 1,
      "explanation": "Проблема зупинки є класичним прикладом нерозв'язної проблеми в теорії обчислень. Алан Тьюринг довів, що не існує алгоритму, який би для довільної програми та її вхідних даних міг би визначити, чи зупиниться ця програма, чи буде працювати нескінченно. Інші варіанти (сортування, пошук шляху, перевірка на простоту) є розв'язними задачами з відомими алгоритмами.",
      "difficulty": "B",
      "section": "АЛГОРИТМИ ТА ОБЧИСЛЮВАЛЬНА СКЛАДНІСТЬ",
      "subsection": "Моделі обчислень",
      "topic": "Розв'язні, напіврозв'язні та нерозв'язні проблеми. Проблема зупинки"
    },
    "АРХІТЕКТУРА ОБЧИСЛЮВАЛЬНИХ СИСТЕМ|Функції бінарної логіки|Булева алгебра та логічні операції": {
      "question": "Яка логічна операція має таку таблицю істинності?\n\n| A | B | Результат |\n|---|---|-----------|\n| 0 | 0 |     1     |\n| 0 | 1 |     1     |\n| 1 | 0 |     1     |\n| 1 | 1 |     0     |",
      "options": [
        "XOR",
        "NAND",
        "NOT",
        "NOR"
      ],
      "correct": 3,
      "explanation": "Таблиця істинності відповідає операції NOR (NOT OR), яка повертає 1 лише коли обидва входи дорівнюють 0, і 0 в усіх інших випадках. Операція NOR є запереченням OR.",
      "difficulty": "B",
      "section": "АРХІТЕКТУРА ОБЧИСЛЮВАЛЬНИХ СИСТЕМ",
      "subsection": "Функції бінарної логіки",
      "topic": "Булева алгебра та логічні операції"
    },
    "АРХІТЕКТУРА ОБЧИСЛЮВАЛЬНИХ СИСТЕМ|Подання даних на рівні машин|Позиційні системи числення. Двійкова, вісімкова, шістнадцяткова системи числення. Беззнаковий код цілих чисел. Доповнювальний код цілих чисел. Основні арифметичні операції над цілими числами в беззнаковому та доповнювальному кодах": {
      "question": "Яке з наведених тверджень є правильним щодо доповнювального коду (two's complement) цілих чисел?",
      "options": [
        "У доповнювальному коді найстарший біт використовується для зберігання знаку, а решта бітів – для модуля числа.",
        "Доповнювальний код дозволяє уникнути неоднозначності представлення нуля.",
        "Для отримання доповнювального коду достатньо інвертувати всі біти числа.",
        "Додавання двох чисел у доповнювальному коді завжди дає правильний результат, навіть при переповненні (overflow)."
      ],
      "correct": 1,
      "explanation": "У доповнювальному коді існує лише одне представлення нуля (усі біти рівні 0), що унеможливлює неоднозначність. Інші варіанти містять помилки: 1) старший біт дійсно вказує знак, але решта бітів – це не просто модуль числа; 2) переповнення при додаванні може спричинити помилковий результат; 3) для отримання доповнювального коду потрібно інвертувати біти та додати 1.",
      "difficulty": "B",
      "section": "АРХІТЕКТУРА ОБЧИСЛЮВАЛЬНИХ СИСТЕМ",
      "subsection": "Подання даних на рівні машин",
      "topic": "Позиційні системи числення. Двійкова, вісімкова, шістнадцяткова системи числення. Беззнаковий код цілих чисел. Доповнювальний код цілих чисел. Основні арифметичні операції над цілими числами в беззнаковому та доповнювальному кодах"
    },
    "АРХІТЕКТУРА ОБЧИСЛЮВАЛЬНИХ СИСТЕМ|Подання даних на рівні машин|Принципи зображення дійсних чисел в пам'яті програми у форматі з плаваючою комою. Переваги та недоліки форматів чисел з плаваючою комою. Основні арифметичні операції над дійсними числами у форматі з плаваючою комою та їхні проблеми": {
      "question": "Яке з наведених тверджень правильно описує проблему 'underflow' у представленні чисел з плаваючою комою за стандартом IEEE 754?",
      "options": [
        "Неможливість точно представити десяткові дроби у двійковій формі.",
        "Результат обчислень настільки малий, що не може бути представлений у заданому діапазоні експоненти.",
        "Втрата точності через обмежену кількість бітів мантиси.",
        "Результат обчислень перевищує максимально допустиме значення, яке може бути представлене у заданому діапазоні експоненти."
      ],
      "correct": 1,
      "explanation": "Underflow виникає, коли результат обчислень є настільки малим, що його експонента виходить за межі мінімально допустимого значення, визначеного стандартом IEEE 754. Це призводить до того, що число не може бути коректно представлене у пам'яті. Інші варіанти описують інші проблеми: overflow (варіант Б), втрату точності (варіант В) та проблему представлення десяткових дробів (варіант Г).",
      "difficulty": "B",
      "section": "АРХІТЕКТУРА ОБЧИСЛЮВАЛЬНИХ СИСТЕМ",
      "subsection": "Подання даних на рівні машин",
      "topic": "Принципи зображення дійсних чисел в пам'яті програми у форматі з плаваючою комою. Переваги та недоліки форматів чисел з плаваючою комою. Основні арифметичні операції над дійсними числами у форматі з плаваючою комою та їхні проблеми"
    },
    "АРХІТЕКТУРА ОБЧИСЛЮВАЛЬНИХ СИСТЕМ|Пристрої введення-виведення. Поняття шини комп'ютера|I/O пристрої та системна шина": {
      "question": "Яка шина відповідає за передачу адреси пам'яті або пристрою, до якого потрібно отримати доступ?",
      "options": [
        "Адресна шина",
        "Системна шина",
        "Шина керування",
        "Шина даних"
      ],
      "correct": 0,
      "explanation": "Адресна шина використовується для передачі адреси пам'яті або пристрою, до якого потрібно отримати доступ. Вона визначає, звідки або куди передаються дані. Шина даних передає самі дані, шина керування — сигнали керування, а системна шина є узагальнюючим поняттям, яке може включати всі вищезазначені шини.",
      "difficulty": "A",
      "section": "АРХІТЕКТУРА ОБЧИСЛЮВАЛЬНИХ СИСТЕМ",
      "subsection": "Пристрої введення-виведення. Поняття шини комп'ютера",
      "topic": "I/O пристрої та системна шина"
    },
    "АРХІТЕКТУРА ОБЧИСЛЮВАЛЬНИХ СИСТЕМ|Функціональна організація обчислювальних систем|Структура комп'ютера, класична архітектура фон Неймана, гарвардська архітектура": {
      "question": "Яка архітектура комп'ютера передбачає роздільну пам'ять для команд і даних?",
      "options": [
        "Гібридна архітектура",
        "Гарвардська архітектура",
        "Модифікована архітектура фон Неймана",
        "Архітектура фон Неймана"
      ],
      "correct": 1,
      "explanation": "Гарвардська архітектура відрізняється від класичної архітектури фон Неймана тим, що використовує окремі фізичні пристрої пам'яті для зберігання команд та даних. Це дозволяє одночасно отримувати команди та дані, що підвищує продуктивність системи.",
      "difficulty": "A",
      "section": "АРХІТЕКТУРА ОБЧИСЛЮВАЛЬНИХ СИСТЕМ",
      "subsection": "Функціональна організація обчислювальних систем",
      "topic": "Структура комп'ютера, класична архітектура фон Неймана, гарвардська архітектура"
    },
    "АРХІТЕКТУРА ОБЧИСЛЮВАЛЬНИХ СИСТЕМ|Функціональна організація обчислювальних систем|Ієрархічний принцип побудови пам'яті – регістрова, кеш, оперативна пам'ять, зовнішня пам'ять. CPU": {
      "question": "Який тип пам'яті в ієрархії пам'яті комп'ютера має найвищу швидкість доступу?",
      "options": [
        "Кеш-пам'ять",
        "Регістрова пам'ять",
        "Оперативна пам'ять (RAM)",
        "Зовнішня пам'ять (наприклад, HDD або SSD)"
      ],
      "correct": 1,
      "explanation": "Регістрова пам'ять має найвищу швидкість доступу, оскільки вона розташована безпосередньо в центральному процесорі (CPU) і використовується для зберігання тимчасових даних під час виконання інструкцій. Кеш-пам'ять також швидка, але повільніша за регістрову, тоді як оперативна пам'ять і зовнішня пам'ять значно повільніші.",
      "difficulty": "A",
      "section": "АРХІТЕКТУРА ОБЧИСЛЮВАЛЬНИХ СИСТЕМ",
      "subsection": "Функціональна організація обчислювальних систем",
      "topic": "Ієрархічний принцип побудови пам'яті – регістрова, кеш, оперативна пам'ять, зовнішня пам'ять. CPU"
    },
    "АРХІТЕКТУРА ОБЧИСЛЮВАЛЬНИХ СИСТЕМ|Функціональна організація обчислювальних систем|Периферійні пристрої": {
      "question": "Який пристрій використовується для введення графічної інформації в комп'ютер шляхом її сканування?",
      "options": [
        "Миша",
        "Монітор",
        "Клавіатура",
        "Сканер"
      ],
      "correct": 3,
      "explanation": "Сканер — це периферійний пристрій, призначений для перетворення зображень або текстів з паперового носія в цифровий формат. Він сканує (зчитує) інформацію та передає її до комп'ютера для подальшої обробки.",
      "difficulty": "A",
      "section": "АРХІТЕКТУРА ОБЧИСЛЮВАЛЬНИХ СИСТЕМ",
      "subsection": "Функціональна організація обчислювальних систем",
      "topic": "Периферійні пристрої"
    },
    "БАЗИ ТА СХОВИЩА ДАНИХ|Ключі та нормалізація даних|Основні нормальні форми (1NF, 2NF, 3NF, BCNF)": {
      "question": "Яка з наведених характеристик є обов'язковою для таблиці, щоб вона відповідала другій нормальній формі (2NF)?",
      "options": [
        "Усі атрибути таблиці залежать лише від суперключа.",
        "Таблиця не містить транзитивних залежностей.",
        "Таблиця знаходиться в 1NF і всі неключові атрибути повністю залежать від первинного ключа.",
        "Усі атрибути таблиці є атомарними."
      ],
      "correct": 2,
      "explanation": "Друга нормальна форма (2NF) вимагає, щоб таблиця спочатку відповідала 1NF (усі атрибути атомарні), а також щоб усі неключові атрибути повністю функціонально залежали від первинного ключа. Це означає, що не повинно бути часткових залежностей неключових атрибутів від частини складеного первинного ключа.",
      "difficulty": "B",
      "section": "БАЗИ ТА СХОВИЩА ДАНИХ",
      "subsection": "Ключі та нормалізація даних",
      "topic": "Основні нормальні форми (1NF, 2NF, 3NF, BCNF)"
    },
    "БАЗИ ТА СХОВИЩА ДАНИХ|Основні концепції систем баз даних|модель даних; мова запитів; транзакція; ACID-властивості транзакцій, індексування; резервне копіювання та відновлення; розподіленість і реплікація даних; безпека даних": {
      "question": "Яка з наведених властивостей ACID гарантує, що транзакція або повністю виконається, або не виконається взагалі?",
      "options": [
        "Durability (Стійкість)",
        "Isolation (Ізольованість)",
        "Atomicity (Атомарність)",
        "Consistency (Узгодженість)"
      ],
      "correct": 2,
      "explanation": "Атомарність (Atomicity) гарантує, що транзакція виконується як єдиний неподільний блок операцій: або всі операції транзакції виконуються успішно, або жодна з них не впливає на стан бази даних. Це запобігає частковому виконанню транзакцій.",
      "difficulty": "B",
      "section": "БАЗИ ТА СХОВИЩА ДАНИХ",
      "subsection": "Основні концепції систем баз даних",
      "topic": "модель даних; мова запитів; транзакція; ACID-властивості транзакцій, індексування; резервне копіювання та відновлення; розподіленість і реплікація даних; безпека даних"
    },
    "БАЗИ ТА СХОВИЩА ДАНИХ|Моделювання даних|створення моделі даних для інформаційної системи; концептуальна, логічна, фізична моделі даних; ER-моделі; нотації ER-моделей": {
      "question": "У системі управління бібліотекою потрібно змоделювати зв'язок між сутностями 'Книга' та 'Автор'. Кожна книга може мати одного або кількох авторів, і кожен автор може бути співавтором однієї або кількох книг. Який тип зв'язку та кардинальність правильно відображають ці відносини у ER-діаграмі (у нотації crow's foot)?",
      "options": [
        "Один до одного (1:1)",
        "Багато до одного (N:1)",
        "Багато до багатьох (M:N)",
        "Один до багатьох (1:N)"
      ],
      "correct": 2,
      "explanation": "Правильна відповідь - 'Багато до багатьох (M:N)', оскільки кожна книга може мати кількох авторів, і кожен автор може бути співавтором кількох книг. У нотації crow's foot це позначається як зв'язок з 'ногими' (три лінії) на обох кінцях.",
      "difficulty": "C",
      "section": "БАЗИ ТА СХОВИЩА ДАНИХ",
      "subsection": "Моделювання даних",
      "topic": "створення моделі даних для інформаційної системи; концептуальна, логічна, фізична моделі даних; ER-моделі; нотації ER-моделей"
    },
    "БАЗИ ТА СХОВИЩА ДАНИХ|Реляційні бази даних|особливості організації та зберігання даних у реляційних базах даних; основні характеристики реляційних баз даних; DBMS (Database Management System)": {
      "question": "Яка основна функція первинного ключа (Primary Key) у реляційній базі даних?",
      "options": [
        "Забезпечення унікальності кожного рядка в таблиці.",
        "Зберігання тимчасових даних для транзакцій.",
        "Зв'язок між двома таблицями через зовнішній ключ.",
        "Автоматичне сортування даних у таблиці."
      ],
      "correct": 0,
      "explanation": "Первинний ключ (Primary Key) у реляційній базі даних використовується для ідентифікації кожного рядка в таблиці унікальним чином. Він гарантує, що жодні два рядки не матимуть однакових значень у стовпці (або наборі стовпців), який визначено як первинний ключ. Це забезпечує цілісність даних і дозволяє ефективно організовувати зв'язки між таблицями.",
      "difficulty": "B",
      "section": "БАЗИ ТА СХОВИЩА ДАНИХ",
      "subsection": "Реляційні бази даних",
      "topic": "особливості організації та зберігання даних у реляційних базах даних; основні характеристики реляційних баз даних; DBMS (Database Management System)"
    },
    "БАЗИ ТА СХОВИЩА ДАНИХ|Побудова запитів|мови SQL (structured query language), DDL (Data Definition Language), DML (Data Manipulation Language), DCL (Data Control Language), TCL (Transaction Control Language)": {
      "question": "У базі даних є таблиця 'Співробітники' з атрибутами: ID, Ім'я, Посада, Зарплата. Потрібно збільшити зарплату на 10% для всіх співробітників, які займають посаду 'Менеджер' та мають зарплату менше 50000. Який SQL-запит правильно виконає це завдання?",
      "options": [
        "INSERT INTO Співробітники (Зарплата) VALUES (Зарплата * 1.1) WHERE Посада = 'Менеджер' AND Зарплата < 50000;",
        "UPDATE Співробітники SET Зарплата = Зарплата * 1.1 WHERE Посада = 'Менеджер' AND Зарплата < 50000;",
        "ALTER TABLE Співробітники MODIFY Зарплата = Зарплата * 1.1 WHERE Посада = 'Менеджер' AND Зарплата < 50000;",
        "SELECT * FROM Співробітники WHERE Посада = 'Менеджер' AND Зарплата < 50000 FOR UPDATE;"
      ],
      "correct": 1,
      "explanation": "Правильний запит використовує команду UPDATE мови DML для зміни даних у таблиці. Він містить умову WHERE для фільтрації рядків, які потрібно оновити (посада 'Менеджер' та зарплата менше 50000), та вираз SET для збільшення зарплати на 10%. Інші варіанти містять синтаксичні помилки або використовують неправильні команди (ALTER TABLE для зміни структури таблиці, SELECT для вибору даних, INSERT для додавання нових записів).",
      "difficulty": "C",
      "section": "БАЗИ ТА СХОВИЩА ДАНИХ",
      "subsection": "Побудова запитів",
      "topic": "мови SQL (structured query language), DDL (Data Definition Language), DML (Data Manipulation Language), DCL (Data Control Language), TCL (Transaction Control Language)"
    },
    "БАЗИ ТА СХОВИЩА ДАНИХ|Обробка запитів|основні операції реляційної алгебри: вибір (selection), проєкція (projection), об'єднання (union), перетин (intersection), різниця (difference), декартовий добуток (cartesian product), об'єднання за атрибутом (Join), ділення (Division)": {
      "question": "Дано дві таблиці: STUDENTS (student_id, name, group_id) та GROUPS (group_id, group_name). Яка операція реляційної алгебри дозволить отримати список імен студентів разом з назвами їх груп?",
      "options": [
        "σ name, group_name (STUDENTS × GROUPS)",
        "STUDENTS ∩ GROUPS",
        "STUDENTS ∪ GROUPS",
        "π name, group_name (STUDENTS ⋈ GROUPS)"
      ],
      "correct": 3,
      "explanation": "Правильна відповідь - операція проєкції (π) після об'єднання за атрибутом (⋈). Операція ⋈ (JOIN) об'єднує таблиці за спільним атрибутом group_id, а операція π (PROJECT) вибирає лише потрібні стовпці (name та group_name). Інші варіанти не підходять: σ (SELECT) фільтрує рядки, а не стовпці; × (CARTESIAN PRODUCT) створить усі можливі комбінації; ∪ (UNION) та ∩ (INTERSECTION) працюють лише з сумісними за структурою таблицями.",
      "difficulty": "C",
      "section": "БАЗИ ТА СХОВИЩА ДАНИХ",
      "subsection": "Обробка запитів",
      "topic": "основні операції реляційної алгебри: вибір (selection), проєкція (projection), об'єднання (union), перетин (intersection), різниця (difference), декартовий добуток (cartesian product), об'єднання за атрибутом (Join), ділення (Division)"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Складні та великі системи|Властивості систем: емерджентність, адитивність, еквіфінальність": {
      "question": "Яка властивість системи проявляється у тому, що система досягає однієї й тієї ж кінцевої мети різними шляхами?",
      "options": [
        "Синергія",
        "Еквіфінальність",
        "Емерджентність",
        "Адитивність"
      ],
      "correct": 1,
      "explanation": "Еквіфінальність — це властивість системи досягати однакового кінцевого стану незалежно від початкових умов або шляхів розвитку. Це означає, що система може використовувати різні методи або стратегії для досягнення однієї й тієї ж мети, що є важливим аспектом у складних системах.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Складні та великі системи",
      "topic": "Властивості систем: емерджентність, адитивність, еквіфінальність"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Складні та великі системи|Відкриті та закриті системи; класифікація за призначенням, походженням, видом елементів, способом організації": {
      "question": "Яка з наведених характеристик є ключовою відмінністю відкритої системи від закритої?",
      "options": [
        "Відкрита система може обмінюватися енергією та інформацією з оточенням, а закрита — ні.",
        "Відкриті системи є виключно штучними, а закриті — природними.",
        "Закрита система завжди має ієрархічну структуру, а відкрита — ні.",
        "Закриті системи можуть еволюціонувати, а відкриті — ні."
      ],
      "correct": 0,
      "explanation": "Відкриті системи характеризуються можливістю взаємодії з оточенням (обмін енергією, інформацією, речовиною), тоді як закриті системи ізольовані від зовнішнього впливу. Ієрархічна структура, походження (природне/штучне) та еволюція не є визначальними критеріями для цього поділу.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Складні та великі системи",
      "topic": "Відкриті та закриті системи; класифікація за призначенням, походженням, видом елементів, способом організації"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Складні та великі системи|Спільне та відмінності складних і великих систем": {
      "question": "Яка з наведених характеристик є спільною для складних і великих систем?",
      "options": [
        "Відсутність емерджентних властивостей",
        "Висока кількість компонентів",
        "Проста структура взаємодій",
        "Неможливість масштабування"
      ],
      "correct": 1,
      "explanation": "Складні та великі системи об'єднує висока кількість компонентів. Складні системи характеризуються складними взаємодіями між компонентами, тоді як великі системи можуть мати простіші взаємодії, але велику кількість елементів. Обидва типи систем можуть бути масштабованими та проявляти емерджентні властивості.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Складні та великі системи",
      "topic": "Спільне та відмінності складних і великих систем"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Моделі систем|Склад і структура системи; моделі типу чорної та білої скриньки": {
      "question": "Яка з наведених характеристик найкраще описує модель 'чорної скриньки' в інженерії систем?",
      "options": [
        "Аналізує внутрішню структуру системи та її компоненти.",
        "Враховує лише вхідні та вихідні дані, без розгляду внутрішніх процесів.",
        "Забезпечує повний опис усіх станів системи в будь-який момент часу.",
        "Використовує детальні математичні моделі всіх внутрішніх зв'язків."
      ],
      "correct": 1,
      "explanation": "Модель 'чорної скриньки' зосереджена виключно на вхідних та вихідних даних системи, ігноруючи її внутрішню структуру та процеси. Це дозволяє аналізувати поведінку системи без необхідності розуміти її внутрішню організацію.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Моделі систем",
      "topic": "Склад і структура системи; моделі типу чорної та білої скриньки"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Моделі систем|Концептуальні, математичні і комп'ютерні моделі": {
      "question": "Яка з наведених характеристик найкраще описує відмінність між концептуальною та комп'ютерною моделлю?",
      "options": [
        "Концептуальна модель є абстрактним представленням системи, а комп'ютерна — її програмною реалізацією.",
        "Концептуальна модель використовується для симуляції, а комп'ютерна — для верифікації.",
        "Концептуальна модель є формалізованою, а комп'ютерна — абстрактною.",
        "Концептуальна модель завжди створюється після комп'ютерної для уточнення деталей."
      ],
      "correct": 0,
      "explanation": "Концептуальна модель — це абстрактне представлення системи, яке описує її основні компоненти та взаємодії без технічних деталей. Комп'ютерна модель є програмною реалізацією, що дозволяє проводити симуляції аналізувати поведінку системи. Інші варіанти містять помилки: концептуальна модель не обов'язково формалізована (1), не лише для симуляції (2), і створюється ДО комп'ютерної (4).",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Моделі систем",
      "topic": "Концептуальні, математичні і комп'ютерні моделі"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Моделі систем|Зв'язок між системою та моделлю; ізо- та гомоморфізм": {
      "question": "Який тип відповідності між системою та її моделлю забезпечує повне збереження структури та властивостей, включаючи взаємно однозначну відповідність елементів?",
      "options": [
        "Гомоморфізм",
        "Абстракція",
        "Аналогія",
        "Ізоморфізм"
      ],
      "correct": 3,
      "explanation": "Ізоморфізм — це тип відповідності між системою та її моделлю, при якому зберігається не тільки структура, а й усі властивості, а також існує взаємно однозначна відповідність між елементами системи та моделі. Гомоморфізм, на відміну від ізоморфізму, може не зберігати всі властивості та не вимагає взаємно однозначної відповідності.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Моделі систем",
      "topic": "Зв'язок між системою та моделлю; ізо- та гомоморфізм"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Інформаційні системи|Поняття, цілі, значення, класифікація за функціональністю, масштабом, сферою застосування": {
      "question": "Яка з наведених систем класифікується як ERP-система?",
      "options": [
        "Система для комплексного управління ресурсами підприємства (ERP)",
        "Система для управління документами (DMS)",
        "Система для управління ланцюгом поставок (SCM)",
        "Система для автоматизації взаємодії з клієнтами (CRM)"
      ],
      "correct": 0,
      "explanation": "ERP (Enterprise Resource Planning) — це система для комплексного управління ресурсами підприємства, яка інтегрує різні бізнес-процеси, такі як фінанси, логістика, виробництво та інші. CRM та SCM є окремими типами систем, а DMS не належить до ERP.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Інформаційні системи",
      "topic": "Поняття, цілі, значення, класифікація за функціональністю, масштабом, сферою застосування"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Інформаційні системи|Забезпечення інформаційних систем: організаційне, інформаційне, математичне, програмне, технічне, лінгвістичне, методичне, правове": {
      "question": "Який вид забезпечення інформаційних систем відповідає за організацію взаємодії користувача з системою через інтерфейс?",
      "options": [
        "Програмне забезпечення.",
        "Лінгвістичне забезпечення.",
        "Організаційне забезпечення.",
        "Технічне забезпечення."
      ],
      "correct": 1,
      "explanation": "Лінгвістичне забезпечення відповідає за засоби спілкування користувача з системою, включаючи інтерфейс, мови запитів, термінологію тощо. Воно забезпечує зручність взаємодії людини з інформаційною системою.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Інформаційні системи",
      "topic": "Забезпечення інформаційних систем: організаційне, інформаційне, математичне, програмне, технічне, лінгвістичне, методичне, правове",
      "unique_id": "957ad374"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Аналіз вимог|Класифікація вимог до програмного забезпечення, джерела та методи збирання вимог": {
      "question": "Який метод збирання вимог до програмного забезпечення передбачає безпосереднє спілкування з замовником або користувачами для отримання інформації про їхні потреби?",
      "options": [
        "Анкетування",
        "Спостереження",
        "Інтерв'ю",
        "Аналіз документів"
      ],
      "correct": 2,
      "explanation": "Інтерв'ю є методом збирання вимог, який передбачає безпосереднє спілкування з замовником або користувачами. Це дозволяє отримати детальну інформацію про їхні потреби, очікування та проблеми, які має вирішити програмне забезпечення. Інші методи, такі як анкетування, спостереження та аналіз документів, є корисними, але не передбачають такого глибокого та особистого контакту.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Аналіз вимог",
      "topic": "Класифікація вимог до програмного забезпечення, джерела та методи збирання вимог"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Аналіз вимог|Вимоги користувача (варіанти використання та історії користувачів)": {
      "question": "Який із наведених елементів є обов'язковим для коректного формування user story?",
      "options": [
        "Роль користувача, дія, цінність",
        "Мова програмування, фреймворк",
        "Технічні вимоги, часові обмеження",
        "Діаграма класів, послідовність дій"
      ],
      "correct": 0,
      "explanation": "User story завжди містить три ключові компоненти: роль користувача (хто), дію (що робить) та цінність (навіщо). Технічні деталі, діаграми чи інструменти не є частиною канонічного формату user story.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Аналіз вимог",
      "topic": "Вимоги користувача (варіанти використання та історії користувачів)"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Аналіз вимог|Функціональні та нефункціональні вимоги, обмеження; структуризація функціональних вимог": {
      "question": "Яка з наведених вимог є нефункціональною?",
      "options": [
        "Система має підтримувати функцію пошуку товарів за категоріями.",
        "Система має дозволяти користувачам додавати товари до кошика.",
        "Система має надавати можливість реєстрації користувачів.",
        "Система має обробляти запити користувачів за час не більше 2 секунд."
      ],
      "correct": 3,
      "explanation": "Нефункціональні вимоги описують якісні характеристики системи, такі як продуктивність, надійність, безпека тощо. Варіант Б ('Система має обробляти запити користувачів за час не більше 2 секунд.') є нефункціональною вимогою, оскільки він визначає критерій продуктивності системи, а не конкретну функціональність.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Аналіз вимог",
      "topic": "Функціональні та нефункціональні вимоги, обмеження; структуризація функціональних вимог"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Проєктування програмного забезпечення|Види проєктування: Структурне проєктування (Structural Design), Об'єктно-орієнтоване проєктування (Object-Oriented Design), Функціональне проєктування (Functional Design), Архітектурне проєктування (Architectural Design), Інтерфейсне проєктування (Interface Design)": {
      "question": "Який підхід до проєктування програмного забезпечення передбачає розбиття системи на модулі з чітко визначеними інтерфейсами?",
      "options": [
        "Об'єктно-орієнтоване проєктування",
        "Структурне проєктування",
        "Функціональне проєктування",
        "Архітектурне проєктування"
      ],
      "correct": 1,
      "explanation": "Структурне проєктування базується на принципі модульності, де система розбивається на модулі з чіткими інтерфейсами для спрощення розробки та супроводу. Це відрізняє його від інших підходів, таких як об'єктно-орієнтоване (орієнтоване на об'єкти та їх взаємодію) чи функціональне (орієнтоване на функції та процеси).",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Проєктування програмного забезпечення",
      "topic": "Види проєктування: Структурне проєктування (Structural Design), Об'єктно-орієнтоване проєктування (Object-Oriented Design), Функціональне проєктування (Functional Design), Архітектурне проєктування (Architectural Design), Інтерфейсне проєктування (Interface Design)"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Проєктування програмного забезпечення|Парадигми проєктування: функціональна декомпозиція згори донизу, архітектура, орієнтована на дані, об'єктно-орієнтований аналіз та проєктування, подієво-керована архітектура": {
      "question": "Яка з наведених парадигм проєктування передбачає розбиття системи на ієрархію функцій, починаючи з загального рівня до деталей?",
      "options": [
        "Архітектура, орієнтована на дані",
        "Функціональна декомпозиція згори донизу",
        "Об'єктно-орієнтований аналіз та проєктування",
        "Подієво-керована архітектура"
      ],
      "correct": 1,
      "explanation": "Функціональна декомпозиція згори донизу — це підхід, при якому система розділяється на функції, починаючи з високорівневих абстракцій і поступово деталізуючи їх до нижчих рівнів. Це відрізняє її від інших парадигм, таких як OOAD (орієнтована на об'єкти) або подієво-керована архітектура (орієнтована на події).",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Проєктування програмного забезпечення",
      "topic": "Парадигми проєктування: функціональна декомпозиція згори донизу, архітектура, орієнтована на дані, об'єктно-орієнтований аналіз та проєктування, подієво-керована архітектура"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Проєктування програмного забезпечення|Ідентифікація класів предметної області. UML-діаграми ієрархії класів: моделювання підсистем, класів та зв'язків між ними": {
      "question": "При проектуванні системи для бібліотеки потрібно відобразити зв'язок між класами 'Книга' та 'Автор'. Який тип зв'язку UML найкраще підходить для випадку, коли книга може мати кількох авторів, а автор може написати кілька книг, при цьому видалення автора не повинно призводити до видалення книг?",
      "options": [
        "Композиція",
        "Агрегація",
        "Наслідування",
        "Асоціація"
      ],
      "correct": 1,
      "explanation": "Агрегація є найбільш підходящим типом зв'язку, оскільки вона відображає відношення 'частина-ціле', де 'частини' (книги) можуть існувати незалежно від 'цілого' (автора). На відміну від композиції, видалення автора не призводить до автоматичного видалення книг. Асоціація також можлива, але агрегація чіткіше підкреслює семантику відношення.",
      "difficulty": "C",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Проєктування програмного забезпечення",
      "topic": "Ідентифікація класів предметної області. UML-діаграми ієрархії класів: моделювання підсистем, класів та зв'язків між ними"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Проєктування програмного забезпечення|Проєктування сценаріїв реалізації варіантів використання на основі UML-діаграм послідовностей та комунікації": {
      "question": "На UML-діаграмі послідовностей об'єкт A відправляє повідомлення об'єкту B, яке вимагає відповіді. Який тип стрілки слід використовувати для відображення цього повідомлення?",
      "options": [
        "Стрілка з ромбоподібним наконечником (diamond arrowhead)",
        "Стрілка з закритим наконечником (filled arrowhead)",
        "Стрілка з відкритим наконечником (open arrowhead)",
        "Пунктирна стрілка з відкритим наконечником (dashed open arrowhead)"
      ],
      "correct": 1,
      "explanation": "На UML-діаграмах послідовностей повідомлення, що вимагають відповіді (синхронні виклики), позначаються стрілками з закритим наконечником (filled arrowhead). Відкритий наконечник використовується для асинхронних повідомлень, ромбоподібний - для створення об'єктів, а пунктирна стрілка - для повернення відповіді.",
      "difficulty": "C",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Проєктування програмного забезпечення",
      "topic": "Проєктування сценаріїв реалізації варіантів використання на основі UML-діаграм послідовностей та комунікації"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Проєктування програмного забезпечення|Основні патерни проєктування: MVC, Abstract Factory, Facade, Decorator, Flyweight, Visitor, Observer, Proxy, Strategy, Chain of Responsibility": {
      "question": "Який патерн проєктування використовується для створення сімейств пов’язаних об’єктів без жорсткої прив’язки до конкретних класів?",
      "options": [
        "Abstract Factory",
        "Observer",
        "Decorator",
        "Strategy"
      ],
      "correct": 0,
      "explanation": "Abstract Factory — це породжувальний патерн, який дозволяє створювати сімейства пов’язаних об’єктів, не прив’язуючись до конкретних класів цих об’єктів. Він особливо корисний, коли система має бути незалежною від способу створення, композиції та представлення об’єктів.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Проєктування програмного забезпечення",
      "topic": "Основні патерни проєктування: MVC, Abstract Factory, Facade, Decorator, Flyweight, Visitor, Observer, Proxy, Strategy, Chain of Responsibility"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Реалізація програмного забезпечення|Вимоги до оформлення коду: стиль, розбиття на структуровані одиниці, найменування змінних, класів, об'єктів": {
      "question": "Який з наведених принципів 'чистого коду' (clean code) передбачає, що функція повинна виконувати лише одне завдання?",
      "options": [
        "Принцип відкритості/закритості (Open/Closed Principle).",
        "Принцип розділення інтерфейсу (Interface Segregation Principle).",
        "Принцип єдиної відповідальності (Single Responsibility Principle).",
        "Принцип підстановки Лісков (Liskov Substitution Principle)."
      ],
      "correct": 2,
      "explanation": "Принцип єдиної відповідальності (Single Responsibility Principle) є частиною SOLID принципів і вимагає, щоб функція або клас мали лише одну причину для змін, тобто виконували лише одне завдання. Це спрощує розуміння, тестування та підтримку коду.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Реалізація програмного забезпечення",
      "topic": "Вимоги до оформлення коду: стиль, розбиття на структуровані одиниці, найменування змінних, класів, об'єктів"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Реалізація програмного забезпечення|Засоби автоматичної генерації програмного коду": {
      "question": "Який із перелічених інструментів є прикладом scaffolding у веб-розробці?",
      "options": [
        "Angular CLI для генерації компонентів, сервісів та модулів",
        "Visual Studio Code з розширенням для автодоповнення коду",
        "Git для контролю версій коду",
        "Docker для контейнеризації застосунків"
      ],
      "correct": 0,
      "explanation": "Scaffolding — це технологія автоматичної генерації базової структури проекту або його частин (наприклад, компонентів, сервісів). Angular CLI — класичний приклад scaffolding-інструменту, оскільки дозволяє швидко створювати готові «каркаси» для різних елементів додатку (наприклад, командою `ng generate component`). Інші варіанти не є scaffolding: Visual Studio Code — IDE, Git — система контролю версій, Docker — інструмент розгортання.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Реалізація програмного забезпечення",
      "topic": "Засоби автоматичної генерації програмного коду"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Реалізація програмного забезпечення|Налагодження: точки зупинки (Breakpoints), спостереження за змінними (Variable Watch), виведення на консоль (Console Output), налагоджувач (Debugger), аналізатори коду (Code Analyzers)": {
      "question": "Який інструмент налагодження дозволяє зупинити виконання програми на певному рядку коду для аналізу стану програми?",
      "options": [
        "Аналізатор коду (Code Analyzer)",
        "Точка зупинки (Breakpoint)",
        "Спостереження за змінними (Variable Watch)",
        "Виведення на консоль (Console Output)"
      ],
      "correct": 1,
      "explanation": "Точка зупинки (Breakpoint) — це інструмент налагодження, який дозволяє зупинити виконання програми на певному рядку коду. Після зупинки розробник може аналізувати стан програми, перевіряти значення змінних та виконувати код покроково. Інші варіанти не є правильними: Спостереження за змінними дозволяє лише відстежувати значення змінних, Виведення на консоль використовується для логування, а Аналізатор коду призначений для виявлення потенційних помилок без зупинки програми.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Реалізація програмного забезпечення",
      "topic": "Налагодження: точки зупинки (Breakpoints), спостереження за змінними (Variable Watch), виведення на консоль (Console Output), налагоджувач (Debugger), аналізатори коду (Code Analyzers)"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Реалізація програмного забезпечення|Керування конфігурацією та версіями програмного забезпечення": {
      "question": "Яка з наведених стратегій гілкування (branching) у Git передбачає створення окремої гілки для кожного нового функціоналу або виправлення помилок, з подальшим їх злиттям у основну гілку після завершення?",
      "options": [
        "Forking Workflow",
        "Trunk-Based Development",
        "Gitflow Workflow",
        "Feature Branch Workflow"
      ],
      "correct": 3,
      "explanation": "Feature Branch Workflow передбачає створення окремої гілки для кожного нового функціоналу або виправлення помилок. Після завершення роботи над функціоналом гілка зливається у основну гілку (наприклад, master або main). Це дозволяє ізолювати зміни та спрощує код-рев'ю.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Реалізація програмного забезпечення",
      "topic": "Керування конфігурацією та версіями програмного забезпечення"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Реалізація програмного забезпечення|Постійна інтеграція/постійне впровадження (Continuous Integration/Continuous Delivery)": {
      "question": "Який інструмент найчастіше використовується для автоматизації CI/CD pipeline?",
      "options": [
        "Adobe Photoshop",
        "Google Chrome",
        "Jenkins",
        "Microsoft Word"
      ],
      "correct": 2,
      "explanation": "Jenkins є одним з найпопулярніших інструментів для автоматизації CI/CD pipeline. Він дозволяє інтегрувати зміни коду, запускати автоматичні тести та розгортати програмне забезпечення. Інші варіанти (Microsoft Word, Adobe Photoshop, Google Chrome) не є інструментами для автоматизації CI/CD.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Реалізація програмного забезпечення",
      "topic": "Постійна інтеграція/постійне впровадження (Continuous Integration/Continuous Delivery)"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Забезпечення якості|Тестування методами білої та чорної скрині": {
      "question": "Розробник використовує метод еквівалентного розбиття (equivalence partitioning) для тестування функції, яка перевіряє, чи є введений вік користувача дійсним (діапазон від 18 до 65 років). Які класи еквівалентності мають бути визначені для цього тестування?",
      "options": [
        "4) Вік ≤ 17, 18 ≤ вік ≤ 65, вік ≥ 66",
        "1) Вік < 18, 18 ≤ вік ≤ 65, вік > 65",
        "2) Вік ≤ 18, 18 < вік < 65, вік ≥ 65",
        "3) Вік < 17, 17 ≤ вік ≤ 66, вік > 66"
      ],
      "correct": 1,
      "explanation": "Метод еквівалентного розбиття передбачає поділ вхідних даних на класи, де кожен клас має однакову поведінку системи. Для функції з діапазоном [18, 65] правильні класи еквівалентності: 1) недійсні значення (вік < 18), 2) дійсні значення (18 ≤ вік ≤ 65), 3) недійсні значення (вік > 65). Варіант 1 точно відповідає цьому поділу.",
      "difficulty": "C",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Забезпечення якості",
      "topic": "Тестування методами білої та чорної скрині"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Забезпечення якості|Рівні тестування: модульний, інтеграційний, системний, валідаційний": {
      "question": "Який рівень тестування перевіряє взаємодію між окремими модулями програмного забезпечення після їх об'єднання?",
      "options": [
        "Валідаційне тестування",
        "Системне тестування",
        "Модульне тестування",
        "Інтеграційне тестування"
      ],
      "correct": 3,
      "explanation": "Інтеграційне тестування перевіряє взаємодію між окремими модулями після їх об'єднання, щоб виявити проблеми на рівні інтерфейсів та спільної роботи. Модульне тестування перевіряє окремі компоненти, системне — всю систему в цілому, а валідаційне — відповідність вимогам користувача.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Забезпечення якості",
      "topic": "Рівні тестування: модульний, інтеграційний, системний, валідаційний"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Забезпечення якості|Розробка через тестування (Test-driven development)": {
      "question": "Яка послідовність етапів у циклі розробки через тестування (TDD) є правильною?",
      "options": [
        "Green → Red → Refactor",
        "Refactor → Red → Green",
        "Red → Green → Refactor",
        "Red → Refactor → Green"
      ],
      "correct": 2,
      "explanation": "Правильна послідовність етапів у TDD циклі: Red (спочатку пишеться тест, який падає), Green (пишеться мінімальний код, щоб тест пройшов), Refactor (покращення коду без зміни його поведінки). Це основоположний принцип TDD.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Забезпечення якості",
      "topic": "Розробка через тестування (Test-driven development)"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Забезпечення якості|Додаткові техніки верифікації та валідації: інспекція коду, перевірка на відповідність стандартам і вимогам, оцінювання зручності використання та користувацького досвіду, перевірка продуктивності та масштабованості": {
      "question": "Яка з перелічених технік верифікації програмного забезпечення передбачає колективний аналіз коду для виявлення дефектів до початку тестування?",
      "options": [
        "Тестування на відповідність (Compliance Testing)",
        "Інспекція коду (Code Review)",
        "Тестування зручності використання (Usability Testing)",
        "Тестування продуктивності (Performance Testing)"
      ],
      "correct": 1,
      "explanation": "Інспекція коду (Code Review) — це формальний процес колективного аналізу програмного коду, метою якого є виявлення дефектів, порушень стандартів кодування та покращення якості коду до початку етапу тестування. Відрізняється від автоматизованих методів тим, що виконується людьми (розробниками, тестувальниками) через ручний перегляд.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Забезпечення якості",
      "topic": "Додаткові техніки верифікації та валідації: інспекція коду, перевірка на відповідність стандартам і вимогам, оцінювання зручності використання та користувацького досвіду, перевірка продуктивності та масштабованості"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Командна робота, підходи до розробки програмного забезпечення (ПЗ)|Класичні моделі розробки ПЗ: каскадна (водоспадна), ітераційна, інкрементна": {
      "question": "Яка з наведених моделей розробки ПЗ передбачає повне завершення кожного етапу перед переходом до наступного?",
      "options": [
        "Ітераційна модель",
        "Інкрементна модель",
        "Гнучка (Agile) модель",
        "Каскадна (водоспадна) модель"
      ],
      "correct": 3,
      "explanation": "Каскадна (водоспадна) модель передбачає лінійний послідовний підхід до розробки ПЗ, де кожен етап (аналіз вимог, проектування, реалізація, тестування, впровадження, супровід) повністю завершується перед переходом до наступного. Це відрізняє її від ітераційних, інкрементних або гнучких моделей, де етапи можуть частково перетинатися або повторюватися.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Командна робота, підходи до розробки програмного забезпечення (ПЗ)",
      "topic": "Класичні моделі розробки ПЗ: каскадна (водоспадна), ітераційна, інкрементна"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Командна робота, підходи до розробки програмного забезпечення (ПЗ)|Промислові технології розробки ПЗ: RUP, MSF, Agile, Scrum, Extreme Programming (XP), Kanban": {
      "question": "Яка з наведених практик Extreme Programming (XP) спрямована на покращення якості коду шляхом його перегляду двома розробниками одночасно?",
      "options": [
        "Непрервна інтеграція",
        "Рефакторинг",
        "Парне програмування",
        "Тестування на основі прийняття"
      ],
      "correct": 2,
      "explanation": "Парне програмування — це практика XP, коли два розробники працюють разом за одним комп'ютером. Один пише код (водій), а другий аналізує та пропонує покращення (навігатор). Це покращує якість коду, зменшує кількість помилок і поширює знання в команді.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Командна робота, підходи до розробки програмного забезпечення (ПЗ)",
      "topic": "Промислові технології розробки ПЗ: RUP, MSF, Agile, Scrum, Extreme Programming (XP), Kanban"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Командна робота, підходи до розробки програмного забезпечення (ПЗ)|Ролі та обов'язки у команді проєкту, переваги командної роботи, ризики та складність такої співпраці": {
      "question": "Яка основна відповідальність Product Owner у Scrum-команді?",
      "options": [
        "Тестування готових функцій перед релізом.",
        "Безпосередня розробка програмного забезпечення.",
        "Максимізація цінності продукту та управління беклогом продукту.",
        "Організація щоденних стендапів та усунення перешкод для команди."
      ],
      "correct": 2,
      "explanation": "Основна відповідальність Product Owner (Власника продукту) полягає у максимізації цінності продукту, який створює команда, та управлінні беклогом продукту. Він визначає пріоритети завдань, формулює вимоги до продукту та забезпечує, що команда розуміє, що потрібно реалізувати. Інші варіанти стосуються обов'язків Scrum Master (організація стендапів) та Development Team (розробка та тестування).",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Командна робота, підходи до розробки програмного забезпечення (ПЗ)",
      "topic": "Ролі та обов'язки у команді проєкту, переваги командної роботи, ризики та складність такої співпраці"
    },
    "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ|Командна робота, підходи до розробки програмного забезпечення (ПЗ)|Основні етапи планування і виконання ІТ проєкту. Життєвий цикл ІТ проєкту": {
      "question": "Який етап життєвого циклу ІТ-проєкту передбачає визначення цілей, масштабу та ключових зацікавлених сторін?",
      "options": [
        "Виконання",
        "Планування",
        "Ініціація",
        "Моніторинг"
      ],
      "correct": 2,
      "explanation": "Етап ініціації включає визначення цілей проєкту, його масштабу, ключових зацікавлених сторін та оцінку життєздатності. Це перший етап, на якому формується уявлення про проєкт перед переходом до детального планування.",
      "difficulty": "B",
      "section": "ІНЖЕНЕРІЯ СИСТЕМ І ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ",
      "subsection": "Командна робота, підходи до розробки програмного забезпечення (ПЗ)",
      "topic": "Основні етапи планування і виконання ІТ проєкту. Життєвий цикл ІТ проєкту"
    },
    "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ|Основи кібербезпеки|Поняття кіберпростору та інформаційного простору": {
      "question": "Що таке кіберпростір у контексті інформаційних технологій?",
      "options": [
        "Програмне забезпечення для захисту даних.",
        "Фізичне середовище, де розташовані комп'ютери та сервери.",
        "Віртуальне середовище, створене комп'ютерними системами та мережами.",
        "Мережа інтернет-провайдерів у певному регіоні."
      ],
      "correct": 2,
      "explanation": "Кіберпростір — це віртуальне середовище, яке утворюється завдяки взаємодії комп'ютерних систем, мереж та цифрових технологій. Воно включає інформаційні потоки, комунікації та ресурси, доступні через інтернет або інші мережі.",
      "difficulty": "A",
      "section": "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ",
      "subsection": "Основи кібербезпеки",
      "topic": "Поняття кіберпростору та інформаційного простору"
    },
    "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ|Основи кібербезпеки|Інформаційна безпека як сфера національної безпеки України, безпеки підприємства/установи, особистої безпеки": {
      "question": "Який з наведених законів є основою нормативно-правової бази кібербезпеки України?",
      "options": [
        "Закон України 'Про кібербезпеку'.",
        "Закон України 'Про основи національної безпеки України'.",
        "Закон України 'Про інформацію'.",
        "Закон України 'Про захист персональних даних'."
      ],
      "correct": 0,
      "explanation": "Закон України 'Про кібербезпеку' є основним нормативно-правовим актом, що регулює сферу кібербезпеки в Україні. Він визначає основні принципи, завдання та механізми забезпечення кібербезпеки на національному рівні, а також правові засади координації діяльності суб'єктів кібербезпеки.",
      "difficulty": "B",
      "section": "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ",
      "subsection": "Основи кібербезпеки",
      "topic": "Інформаційна безпека як сфера національної безпеки України, безпеки підприємства/установи, особистої безпеки"
    },
    "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ|Основи кібербезпеки|Поняття кібербезпеки, захисту інформації та кіберзахисту": {
      "question": "Яке з наведених визначень найточніше описує поняття 'кібербезпека'?",
      "options": [
        "Технології та практики, що забезпечують безпеку фізичної інфраструктури інформаційних систем.",
        "Процес захисту даних від несанкціонованого доступу або змін, незалежно від їхнього формату.",
        "Комплекс заходів, спрямованих на захист інформації в цифровому середовищі, включаючи мережі, комп'ютери та програми.",
        "Методи захисту конфіденційності лише в корпоративних мережах."
      ],
      "correct": 2,
      "explanation": "Кібербезпека охоплює захист інформації в цифровому середовищі, включаючи мережі, комп'ютери та програми, що робить перший варіант найточнішим. Інші варіанти або звузькують поняття, або не враховують усіх його аспектів.",
      "difficulty": "B",
      "section": "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ",
      "subsection": "Основи кібербезпеки",
      "topic": "Поняття кібербезпеки, захисту інформації та кіберзахисту"
    },
    "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ|Основи кібербезпеки|Види захисту інформації: технічний, інженерний криптографічний, організаційний": {
      "question": "Який вид захисту інформації передбачає використання систем контролю доступу, відеоспостереження та сигналізації?",
      "options": [
        "Інженерний захист",
        "Технічний захист",
        "Організаційний захист",
        "Криптографічний захист"
      ],
      "correct": 0,
      "explanation": "Інженерний захист інформації передбачає використання фізичних засобів захисту, таких як системи контролю доступу, відеоспостереження та сигналізація, для запобігання несанкціонованому доступу до інформаційних ресурсів. Це відрізняється від технічного захисту (програмні засоби), криптографічного (шифрування) та організаційного (політики та навчання).",
      "difficulty": "B",
      "section": "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ",
      "subsection": "Основи кібербезпеки",
      "topic": "Види захисту інформації: технічний, інженерний криптографічний, організаційний"
    },
    "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ|Основи кібербезпеки|Поняття конфіденційності, цілісності, доступності": {
      "question": "Який принцип CIA тріади порушується, коли зловмисник змінює дані в базі даних без відома власника?",
      "options": [
        "Доступність",
        "Конфіденційність",
        "Цілісність",
        "Автентифікація"
      ],
      "correct": 2,
      "explanation": "У цьому випадку порушується принцип цілісності (Integrity), оскільки дані були змінені несанкціоновано, що призвело до втрати їх достовірності. Цілісність у CIA тріаді стосується захисту даних від несанкціонованих змін.",
      "difficulty": "B",
      "section": "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ",
      "subsection": "Основи кібербезпеки",
      "topic": "Поняття конфіденційності, цілісності, доступності",
      "unique_id": "40ab3fdd"
    },
    "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ|Основи кібербезпеки|Принципи кібербезпеки": {
      "question": "Який принцип кібербезпеки передбачає надання користувачам лише тих прав доступу, які є необхідними для виконання їхніх обов'язків?",
      "options": [
        "Мінімальні привілеї",
        "Шарування захисту",
        "Розділення обов'язків",
        "Оборона в глибину"
      ],
      "correct": 0,
      "explanation": "Принцип 'Мінімальні привілеї' (Principle of Least Privilege, PoLP) полягає в тому, що користувачі або процеси повинні мати лише ті права доступу, які є абсолютно необхідними для виконання їхніх завдань. Це зменшує ризик зловживання або компрометації облікових записів.",
      "difficulty": "A",
      "section": "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ",
      "subsection": "Основи кібербезпеки",
      "topic": "Принципи кібербезпеки"
    },
    "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ|Кіберзагрози та кібератаки|Поняття загроз, атак, вразливості": {
      "question": "Що таке кіберзагроза в контексті інформаційної безпеки?",
      "options": [
        "Фізичний доступ до серверного обладнання.",
        "Метод шифрування даних.",
        "Програмне забезпечення для захисту від вірусів.",
        "Будь-яка потенційна подія або дія, яка може завдати шкоди інформаційній системі або даним."
      ],
      "correct": 3,
      "explanation": "Кіберзагроза — це будь-яка потенційна подія або дія, яка може порушити конфіденційність, цілісність або доступність інформаційної системи або даних. Вона може бути наслідком зловмисних дій (наприклад, кібератак) або випадкових подій (наприклад, природних катастроф). Інші варіанти не відповідають визначенню кіберзагрози.",
      "difficulty": "A",
      "section": "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ",
      "subsection": "Кіберзагрози та кібератаки",
      "topic": "Поняття загроз, атак, вразливості"
    },
    "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ|Кіберзагрози та кібератаки|Класифікація загроз, атак": {
      "question": "Яка з перелічених кібератак є прикладом активної загрози?",
      "options": [
        "Відправка фішингових листів",
        "Прослуховування мережевого трафіку",
        "Аналіз відкритих джерел інформації",
        "Зберігання даних без авторизації"
      ],
      "correct": 0,
      "explanation": "Активні загрози передбачають безпосередні дії зі зміни даних або систем, тоді як пасивні лише збирають інформацію. Відправка фішингових листів - це активна дія, спрямована на обман користувачів, тоді як інші варіанти є прикладами пасивного збору інформації.",
      "difficulty": "B",
      "section": "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ",
      "subsection": "Кіберзагрози та кібератаки",
      "topic": "Класифікація загроз, атак"
    },
    "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ|Кіберзагрози та кібератаки|Кіберзлочини. Кібервійна. Кібероборона": {
      "question": "Який із наведених типів кіберзлочинів найчастіше використовується APT-групами для тривалого та прихованого доступу до системи?",
      "options": [
        "Видобуток криптовалют за допомогою чужого обладнання",
        "Фішинг",
        "Внедрення шкідливого ПЗ з функцією віддаленого доступу",
        "DDoS-атаки"
      ],
      "correct": 2,
      "explanation": "APT-групи (Advanced Persistent Threat) спеціалізуються на тривалих та прихованих атаках, де основним інструментом є шкідливе ПЗ з функцією віддаленого доступу (наприклад, бекдори або трояни). Це дозволяє їм підтримувати доступ до системи, викрадати дані або контролювати інфраструктуру без виявлення. Інші варіанти (фішинг, DDoS, криптоджекінг) можуть використовуватися, але не є основним методом для APT.",
      "difficulty": "B",
      "section": "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ",
      "subsection": "Кіберзагрози та кібератаки",
      "topic": "Кіберзлочини. Кібервійна. Кібероборона"
    },
    "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ|Кіберзагрози та кібератаки|Кібертероризм. Кіберрозвідка": {
      "question": "Який із наведених методів кіберрозвідки відноситься до OSINT?",
      "options": [
        "Зловмисне програмне забезпечення для збору даних.",
        "Фізичне проникнення на об'єкт для збору інформації.",
        "Використання шпигунського ПЗ для перехоплення комунікацій.",
        "Аналіз відкритих джерел інформації, таких як соціальні мережі та публічні бази даних."
      ],
      "correct": 3,
      "explanation": "OSINT (Open Source Intelligence) — це метод кіберрозвідки, який передбачає збір та аналіз інформації з відкритих джерел, таких як соціальні мережі, вебсайти, публічні звіти тощо. Він є легальним і не вимагає додаткових дозволів, на відміну від методів, що передбачають зловмисні дії або фізичне проникнення.",
      "difficulty": "B",
      "section": "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ",
      "subsection": "Кіберзагрози та кібератаки",
      "topic": "Кібертероризм. Кіберрозвідка"
    },
    "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ|Кіберзагрози та кібератаки|Модель порушника": {
      "question": "Який тип загрози інформаційній безпеці представляє колишній співробітник компанії, який має доступ до конфіденційних даних та мотивований помстою?",
      "options": [
        "Внутрішня загроза (insider threat)",
        "Фізична загроза",
        "Випадкова загроза",
        "Зовнішня загроза (outsider threat)"
      ],
      "correct": 0,
      "explanation": "Колишній співробітник, який має доступ до конфіденційних даних та мотивований помстою, є прикладом внутрішньої загрози (insider threat). Внутрішні загрози виникають від осіб, які мають або мали легальний доступ до систем або даних організації, на відміну від зовнішніх загроз, які надходять від осіб або груп ззовні організації.",
      "difficulty": "B",
      "section": "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ",
      "subsection": "Кіберзагрози та кібератаки",
      "topic": "Модель порушника"
    },
    "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ|Кіберзагрози та кібератаки|Поняття, сутність та основні завдання комплексної системи захисту інформації": {
      "question": "Який принцип комплексного захисту інформації передбачає одночасне використання різних рівнів та методів захисту?",
      "options": [
        "Фізичний захист",
        "Багаторівневий захист",
        "Шифрування даних",
        "Резервне копіювання"
      ],
      "correct": 1,
      "explanation": "Багаторівневий захист є основним принципом комплексної системи захисту інформації, який передбачає використання різних рівнів (фізичного, технічного, програмного, організаційного) та методів захисту для створення ефективного бар'єру проти кіберзагроз. Це дозволяє мінімізувати ризики, оскільки навіть якщо один рівень захисту буде порушено, інші рівні продовжуватимуть функціонувати.",
      "difficulty": "B",
      "section": "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ",
      "subsection": "Кіберзагрози та кібератаки",
      "topic": "Поняття, сутність та основні завдання комплексної системи захисту інформації"
    },
    "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ|Безпека мережі|Поняття про шкідливе програмне забезпечення": {
      "question": "Який тип шкідливого програмного забезпечення маскується під корисне ПЗ, але насправді надає зловмисникам контроль над системою?",
      "options": [
        "Мережевий черв'як",
        "Троянський кінь",
        "Руткіт",
        "Комп'ютерний вірус"
      ],
      "correct": 1,
      "explanation": "Троянський кінь — це тип шкідливого ПЗ, який маскується під корисне або законне програмне забезпечення. На відміну від вірусів або черв'яків, трояни не саморозповсюджуються, але надають зловмисникам контроль над зараженою системою, часто без відома користувача.",
      "difficulty": "B",
      "section": "КІБЕРБЕЗПЕКА ТА ЗАХИСТ ІНФОРМАЦІЇ",
      "subsection": "Безпека мережі",
      "topic": "Поняття про шкідливе програмне забезпечення"
    },
    "МАТЕМАТИКА В ІТ|Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ|Обчислення визначених інтегралів (метод прямокутників, метод трапецій)": {
      "question": "Який метод чисельного інтегрування має меншу похибку при однаковій кількості інтервалів розбиття: метод прямокутників чи метод трапецій?",
      "options": [
        "Обидва методи мають однакову похибку.",
        "Метод прямокутників, оскільки він простіший у реалізації.",
        "Метод трапецій, оскільки він точніше апроксимує площу під кривою.",
        "Метод прямокутників, оскільки він використовує менше обчислень."
      ],
      "correct": 2,
      "explanation": "Метод трапецій має меншу похибку порівняно з методом прямокутників при однаковій кількості інтервалів, оскільки він краще апроксимує площу під кривою за рахунок використання лінійної інтерполяції між точками, а не постійного значення, як у методі прямокутників.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ",
      "topic": "Обчислення визначених інтегралів (метод прямокутників, метод трапецій)"
    },
    "МАТЕМАТИКА В ІТ|Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ|Застосування функцій багатьох змінних. Частинні похідні. Необхідні і достатні умови екстремуму": {
      "question": "Який математичний об'єкт використовується для визначення характеру екстремуму функції багатьох змінних (максимум, мінімум чи сідлова точка)?",
      "options": [
        "Якобіан",
        "Лапласіан",
        "Гессіан",
        "Градієнт"
      ],
      "correct": 2,
      "explanation": "Гессіан (матриця других похідних) дозволяє визначити характер екстремуму. Для цього аналізують його визначник та власні значення: якщо всі власні значення додатні - точка мінімуму, від'ємні - максимуму, різних знаків - сідлова точка.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ",
      "topic": "Застосування функцій багатьох змінних. Частинні похідні. Необхідні і достатні умови екстремуму"
    },
    "МАТЕМАТИКА В ІТ|Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ|Методи оптимізації: Основні поняття та цілі в задачах лінійного та нелінійного програмування. Метод градієнтного спуску: ідея та алгоритм": {
      "question": "Яка основна ідея методу градієнтного спуску в задачах оптимізації?",
      "options": [
        "Максимізація цільової функції шляхом руху в напрямку градієнта.",
        "Знаходження глобального мінімуму за один крок за допомогою аналітичного розв'язку.",
        "Випадковий пошук мінімуму функції без використання похідних.",
        "Послідовне наближення до мінімуму функції шляхом руху в напрямку, протилежному градієнту."
      ],
      "correct": 3,
      "explanation": "Метод градієнтного спуску базується на ідеї послідовного наближення до мінімуму функції. На кожному кроці алгоритм обчислює градієнт функції в поточній точці та рухається в напрямку, протилежному градієнту (оскільки градієнт вказує напрямок найшвидшого зростання функції). Це дозволяє поступово зменшувати значення функції та наближатися до локального мінімуму.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ",
      "topic": "Методи оптимізації: Основні поняття та цілі в задачах лінійного та нелінійного програмування. Метод градієнтного спуску: ідея та алгоритм"
    },
    "МАТЕМАТИКА В ІТ|Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ|Апроксимація даних. Метод найменших квадратів (лінійна залежність)": {
      "question": "За даними експерименту отримано наступні точки: (1, 2), (2, 3), (3, 5), (4, 4). Використовуючи метод найменших квадратів для лінійної регресії y = ax + b, обчисліть коефіцієнти a та b. Які значення будуть найбільш близькими до правильних?",
      "options": [
        "a ≈ 1.2, b ≈ 0.6",
        "a ≈ 0.6, b ≈ 1.8",
        "a ≈ 1.0, b ≈ 1.0",
        "a ≈ 0.8, b ≈ 1.4"
      ],
      "correct": 3,
      "explanation": "Для знаходження коефіцієнтів a та b методом найменших квадратів використовуються формули: a = (nΣxy - ΣxΣy) / (nΣx² - (Σx)²), b = (Σy - aΣx) / n. Після підстановки значень отримуємо: a ≈ 0.8, b ≈ 1.4. Це мінімізує суму квадратів похибок для даних точок.",
      "difficulty": "C",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ",
      "topic": "Апроксимація даних. Метод найменших квадратів (лінійна залежність)"
    },
    "МАТЕМАТИКА В ІТ|Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ|Числові ряди та поняття їх збіжності. Степеневі ряди": {
      "question": "Який з наведених рядів є збіжним за ознакою Даламбера?",
      "options": [
        "∑ (n=1 до ∞) 1 / n^2",
        "∑ (n=1 до ∞) n! / 3^n",
        "∑ (n=1 до ∞) (-1)^n / n",
        "∑ (n=1 до ∞) 3^n / n!"
      ],
      "correct": 3,
      "explanation": "Ознака Даламбера використовується для визначення збіжності рядів з додатними членами. Вона полягає в обчисленні границі lim (n→∞) |a_{n+1} / a_n|. Якщо ця границя менша за 1, ряд збігається. Для ряду ∑ (n=1 до ∞) 3^n / n! обчислюємо lim (n→∞) (3^{n+1} / (n+1)!) / (3^n / n!) = lim (n→∞) 3 / (n+1) = 0 < 1, тому ряд збігається. Інші варіанти: перший ряд розбігається (границя > 1), другий збігається за інтегральною ознакою, третій — за ознакою Лейбніца, але не за Даламбера.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ",
      "topic": "Числові ряди та поняття їх збіжності. Степеневі ряди"
    },
    "МАТЕМАТИКА В ІТ|Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ|Основні означення теорії диференціальних рівнянь: порядок диференціального рівняння, частинний розв'язок, загальний розв'язок, задача Коші. Поняття про ітераційні методи їх розв'язування": {
      "question": "Яке з наведених тверджень правильно описує загальний розв'язок звичайного диференціального рівняння (ОДР)?",
      "options": [
        "Це розв'язок, який визначається лише для лінійних диференціальних рівнянь.",
        "Це сімейство розв'язків, яке містить усі можливі розв'язки рівняння, включаючи довільні константи.",
        "Це конкретний розв'язок, який задовольняє початкові умови задачі Коші.",
        "Це наближений розв'язок, отриманий ітераційними методами."
      ],
      "correct": 1,
      "explanation": "Загальний розв'язок ОДР — це сімейство функцій, яке містить усі можливі розв'язки рівняння. Він включає довільні константи, кількість яких дорівнює порядку рівняння. Частинний розв'язок отримується із загального шляхом визначення цих констант за початковими умовами (задача Коші). Ітераційні методи використовуються для наближеного розв'язання, але не визначають загальний розв'язок. Лінійність рівняння також не є обов'язковою умовою для існування загального розв'язку.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ",
      "topic": "Основні означення теорії диференціальних рівнянь: порядок диференціального рівняння, частинний розв'язок, загальний розв'язок, задача Коші. Поняття про ітераційні методи їх розв'язування"
    },
    "МАТЕМАТИКА В ІТ|Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ|Пряма і площина в просторі. Поняття гіперплощини. Криві і поверхні другого порядку. Еліпс, гіпербола, парабола": {
      "question": "Яке з наведених рівнянь описує гіперплощину в тривимірному просторі?",
      "options": [
        "x²/a² + y²/b² - z²/c² = 1",
        "y = kx + b",
        "ax + by + cz + d = 0",
        "x² + y² + z² = r²"
      ],
      "correct": 2,
      "explanation": "Гіперплощина в n-вимірному просторі задається лінійним рівнянням виду a₁x₁ + a₂x₂ + ... + aₙxₙ + b = 0. У тривимірному випадку (n=3) це звичайна площина ax + by + cz + d = 0. Інші варіанти: перший - сфера, третій - гіперболоїд, четвертий - рівняння прямої на площині.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ",
      "topic": "Пряма і площина в просторі. Поняття гіперплощини. Криві і поверхні другого порядку. Еліпс, гіпербола, парабола"
    },
    "МАТЕМАТИКА В ІТ|Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ|Матриці та дії з матрицями. Визначники. Обернена матриця": {
      "question": "Яка з наведених операцій над матрицями є комутативною?",
      "options": [
        "Знаходження оберненої матриці",
        "Транспонування матриці",
        "Множення матриць",
        "Додавання матриць однакового розміру"
      ],
      "correct": 3,
      "explanation": "Додавання матриць однакового розміру є комутативною операцією, оскільки A + B = B + A для будь-яких матриць A та B однакового розміру. Інші операції (множення, знаходження оберненої матриці, транспонування) не є комутативними.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ",
      "topic": "Матриці та дії з матрицями. Визначники. Обернена матриця"
    },
    "МАТЕМАТИКА В ІТ|Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ|Власні вектори та власні числа матриці": {
      "question": "Який з наведених методів використовує власні вектори та власні числа матриці для зменшення розмірності даних?",
      "options": [
        "Метод кластеризації k-середніх (k-means)",
        "Метод опорних векторів (SVM)",
        "Метод головних компонент (PCA)",
        "Метод k-найближчих сусідів (k-NN)"
      ],
      "correct": 2,
      "explanation": "Метод головних компонент (PCA) використовує власні вектори та власні числа матриці коваріації даних для знаходження напрямків максимальної дисперсії. Ці напрямки (головні компоненти) дозволяють зменшити розмірність даних, зберігаючи при цьому максимальну інформацію. Інші методи (k-NN, SVM, k-means) не використовують власні вектори для зменшення розмірності.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ",
      "topic": "Власні вектори та власні числа матриці"
    },
    "МАТЕМАТИКА В ІТ|Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ|Системи лінійних алгебраїчних рівнянь, умови їх розв'язності. Чисельні методи їх розв'язання": {
      "question": "Яка основна відмінність між методом Гаусса та LU-розкладом при розв'язанні систем лінійних алгебраїчних рівнянь?",
      "options": [
        "Метод Гаусса виконує прямі перетворення матриці до трикутного вигляду, а LU-розклад розкладає матрицю на дві трикутні матриці.",
        "Метод Гаусса застосовується тільки для симетричних матриць, а LU-розклад — для будь-яких.",
        "Метод Гаусса використовує ітерації, а LU-розклад — прямі обчислення.",
        "Метод Гаусса потребує менше обчислювальних ресурсів, ніж LU-розклад."
      ],
      "correct": 0,
      "explanation": "Метод Гаусса полягає у послідовному перетворенні матриці системи до верхнього трикутного вигляду за допомогою елементарних перетворень, тоді як LU-розклад розкладає матрицю на добуток нижньої (L) та верхньої (U) трикутних матриць. Це дозволяє використовувати LU-розклад для багаторазового розв'язання систем з однаковою матрицею, що є його перевагою.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ",
      "topic": "Системи лінійних алгебраїчних рівнянь, умови їх розв'язності. Чисельні методи їх розв'язання"
    },
    "МАТЕМАТИКА В ІТ|Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ|Лінійний векторний простір та його основні властивості. Розмірність і базис простору": {
      "question": "Яка з наведених властивостей є однією з основних властивостей лінійного векторного простору?",
      "options": [
        "Комутативність операції скалярного множення.",
        "Наявність оберненого елемента для операції множення векторів.",
        "Замкненість відносно операції додавання векторів.",
        "Асоціативність операції взяття норми вектора."
      ],
      "correct": 2,
      "explanation": "Лінійний векторний простір має дві основні операції: додавання векторів і множення вектора на скаляр. Однією з ключових властивостей є замкненість відносно додавання: сума будь-яких двох векторів простору також належить цьому простору. Інші варіанти не є основними властивостями лінійного простору.",
      "difficulty": "A",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування методів математичного аналізу, аналітичної геометрії, лінійної алгебри в ІТ",
      "topic": "Лінійний векторний простір та його основні властивості. Розмірність і базис простору"
    },
    "МАТЕМАТИКА В ІТ|Дискретна математика|Поняття множини. Операції над множинами: об'єднання, перетин, різниця, доповнення, булеан множини, декартів добуток": {
      "question": "Нехай A = {1, 2, 3}, B = {3, 4, 5}. Визначте, яка з наведених множин є результатом операції (A \\ B) × (B ∩ A), де '\\' — різниця множин, '×' — декартів добуток, '∩' — перетин множин.",
      "options": [
        "{(1, 3), (2, 3), (3, 3)}",
        "∅ (порожня множина)",
        "{(3, 1), (3, 2)}",
        "{(1, 3), (2, 3)}"
      ],
      "correct": 3,
      "explanation": "1. Спочатку обчислюємо A \\ B = {1, 2} (елементи з A, яких немає в B).\n2. Потім B ∩ A = {3} (спільний елемент).\n3. Декартів добуток {1, 2} × {3} = {(1, 3), (2, 3)}.",
      "difficulty": "C",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Дискретна математика",
      "topic": "Поняття множини. Операції над множинами: об'єднання, перетин, різниця, доповнення, булеан множини, декартів добуток"
    },
    "МАТЕМАТИКА В ІТ|Дискретна математика|Бінарні відношення та їх властивості: рефлексивність, симетричність, транзитивність": {
      "question": "Яка з наведених властивостей є обов'язковою для відношення еквівалентності?",
      "options": [
        "Антисиметричність",
        "Антирефлексивність",
        "Рефлексивність",
        "Асиметричність"
      ],
      "correct": 2,
      "explanation": "Відношення еквівалентності обов'язково має бути рефлексивним, симетричним та транзитивним. Рефлексивність означає, що кожен елемент пов'язаний із самим собою, що є однією з основних вимог для відношення еквівалентності. Інші варіанти (антисиметричність, антирефлексивність, асиметричність) не є властивостями відношення еквівалентності.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Дискретна математика",
      "topic": "Бінарні відношення та їх властивості: рефлексивність, симетричність, транзитивність"
    },
    "МАТЕМАТИКА В ІТ|Дискретна математика|Комбінаторний аналіз. Правило суми та добутку. Сполуки, перестановки, розміщення: без повторень та з повтореннями. Принцип включень і виключень": {
      "question": "Скількома способами можна розсадити 5 студентів на 10 місцях, якщо кожен студент займає одне місце?",
      "options": [
        "50",
        "30240",
        "120",
        "100000"
      ],
      "correct": 1,
      "explanation": "Це задача на розміщення без повторень. Кількість способів розсадити 5 студентів на 10 місцях обчислюється за формулою розміщень: A(n, k) = n! / (n - k)!, де n = 10 (місць), k = 5 (студентів). Отже, A(10, 5) = 10! / (10 - 5)! = 10! / 5! = 30240.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Дискретна математика",
      "topic": "Комбінаторний аналіз. Правило суми та добутку. Сполуки, перестановки, розміщення: без повторень та з повтореннями. Принцип включень і виключень"
    },
    "МАТЕМАТИКА В ІТ|Дискретна математика|Елементи математичної логіки. Логічні сполучники": {
      "question": "Який логічний сполучник відповідає виразу 'якщо A, то B' у математичній логіці?",
      "options": [
        "Диз'юнкція",
        "Кон'юнкція",
        "Еквіваленція",
        "Імплікація"
      ],
      "correct": 3,
      "explanation": "Імплікація (позначається як A → B) відповідає логічному виразу 'якщо A, то B'. Вона є хибною лише тоді, коли A істинне, а B хибне. Кон'юнкція (A ∧ B) — це 'A і B', диз'юнкція (A ∨ B) — 'A або B', а еквіваленція (A ↔ B) — 'A тоді і лише тоді, коли B'.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Дискретна математика",
      "topic": "Елементи математичної логіки. Логічні сполучники"
    },
    "МАТЕМАТИКА В ІТ|Дискретна математика|Таблиці істинності. Булеві функції. Форми подання булевих функцій. Логіка висловлювань": {
      "question": "Яка з наведених форм представлення булевої функції є досконалою диз'юнктивною нормальною формою (СДНФ)?",
      "options": [
        "Форма, яка містить диз'юнкції всіх можливих наборів аргументів, для яких функція набуває значення 0.",
        "Форма, яка містить мінімальну кількість логічних операцій для представлення функції.",
        "Форма, яка використовує лише операції заперечення та кон'юнкції.",
        "Форма, яка містить кон'юнкції всіх можливих наборів аргументів, для яких функція набуває значення 1."
      ],
      "correct": 3,
      "explanation": "Досконала диз'юнктивна нормальна форма (СДНФ) — це форма представлення булевої функції у вигляді диз'юнкції кон'юнкцій, де кожна кон'юнкція відповідає одному набору аргументів, для яких функція набуває значення 1. Таким чином, перший варіант є правильним, оскільки він точно описує СДНФ.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Дискретна математика",
      "topic": "Таблиці істинності. Булеві функції. Форми подання булевих функцій. Логіка висловлювань"
    },
    "МАТЕМАТИКА В ІТ|Дискретна математика|Графи. Типи графів: Орієнтовні та неорієнтовні графи. Вершини та ребра, ступінь вершини, суміжність. Ізоморфізм графів. Операції над графами: об'єднання, пряма сума, доповнення, вилучення ребра, вилучення вершини": {
      "question": "Яка матриця використовується для представлення орієнтованого графа, де елемент матриці вказує наявність ребра між вершинами?",
      "options": [
        "Матриця інцидентності",
        "Матриця суміжності",
        "Матриця досяжності",
        "Матриця ваг"
      ],
      "correct": 1,
      "explanation": "Матриця суміжності використовується для представлення орієнтованого графа, де елемент a[i][j] дорівнює 1, якщо існує ребро з вершини i до вершини j, і 0 в іншому випадку. Матриця інцидентності використовується для представлення ребер, а матриця ваг — для зважених графів. Матриця досяжності показує можливість досягнення однієї вершини з іншої.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Дискретна математика",
      "topic": "Графи. Типи графів: Орієнтовні та неорієнтовні графи. Вершини та ребра, ступінь вершини, суміжність. Ізоморфізм графів. Операції над графами: об'єднання, пряма сума, доповнення, вилучення ребра, вилучення вершини"
    },
    "МАТЕМАТИКА В ІТ|Дискретна математика|Маршрути, ланцюги, цикли та їх різновиди у графах": {
      "question": "Який шлях у графі називається ейлеровим?",
      "options": [
        "Шлях, що починається і закінчується в одній вершині, проходячи через кожне ребро рівно один раз.",
        "Шлях, що проходить через кожне ребро графа рівно один раз.",
        "Шлях, що містить всі вершини графа, але може проходити через ребра більше одного разу.",
        "Шлях, що проходить через кожну вершину графа рівно один раз."
      ],
      "correct": 1,
      "explanation": "Ейлеровим шляхом називається такий шлях у графі, який проходить через кожне ребро графа рівно один раз. Він не обов'язково має починатися і закінчуватися в одній вершині (це буде ейлерів цикл). Важливою умовою є те, що кожне ребро відвідується лише один раз.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Дискретна математика",
      "topic": "Маршрути, ланцюги, цикли та їх різновиди у графах"
    },
    "МАТЕМАТИКА В ІТ|Дискретна математика|Зв'язність графів, компоненти зв'язності неорієнтованих графів. Відстань між вершинами": {
      "question": "Якщо в неорієнтованому графі будь-які дві вершини можна з'єднати шляхом, то такий граф називається:",
      "options": [
        "Сильно зв'язним",
        "Зв'язним",
        "Деревом",
        "Повним"
      ],
      "correct": 1,
      "explanation": "Неорієнтований граф називається зв'язним, якщо між будь-якими двома його вершинами існує шлях. Сильна зв'язність стосується орієнтованих графів, дерево — це окремий вид зв'язного графа без циклів, а повний граф — це граф, у якому кожна вершина з'єднана з кожною іншою.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Дискретна математика",
      "topic": "Зв'язність графів, компоненти зв'язності неорієнтованих графів. Відстань між вершинами"
    },
    "МАТЕМАТИКА В ІТ|Дискретна математика|Дерева, ліси: основні поняття": {
      "question": "Яка з наведених властивостей є обов’язковою для дерева?",
      "options": [
        "Наявність паралельних ребер.",
        "Наявність циклів.",
        "Зв’язність графа.",
        "Орієнтованість графа."
      ],
      "correct": 2,
      "explanation": "Дерево — це зв’язний граф без циклів. Таким чином, обов’язковою властивістю дерева є зв’язність, оскільки всі його вершини повинні бути зв’язані між собою, а циклів і паралельних ребер бути не може. Орієнтованість не є обов’язковою, оскільки дерева можуть бути як орієнтованими, так і неорієнтованими.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Дискретна математика",
      "topic": "Дерева, ліси: основні поняття"
    },
    "МАТЕМАТИКА В ІТ|Застосування теорії ймовірностей та математичної статистики в ІТ|Стохастичний експеримент. Простір елементарних подій. Операції над подіями. Комбінаторна та геометрична ймовірності. Умовна ймовірність": {
      "question": "Яке з наведених тверджень правильно описує простір елементарних подій Ω у стохастичному експерименті?",
      "options": [
        "Множина всіх підмножин множини можливих результатів експерименту.",
        "Множина всіх можливих результатів експерименту, які є взаємно виключними та рівноможливими.",
        "Множина всіх результатів експерименту, які є залежними між собою.",
        "Множина всіх можливих комбінацій результатів експерименту, незалежно від їхньої ймовірності."
      ],
      "correct": 1,
      "explanation": "Простір елементарних подій Ω визначається як множина всіх можливих результатів стохастичного експерименту, які є взаємно виключними (не можуть відбутися одночасно) та рівноможливими (мають однакову ймовірність). Це фундаментальне поняття теорії ймовірностей, на основі якого будуються інші визначення, такі як алгебра подій та ймовірнісна міра.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування теорії ймовірностей та математичної статистики в ІТ",
      "topic": "Стохастичний експеримент. Простір елементарних подій. Операції над подіями. Комбінаторна та геометрична ймовірності. Умовна ймовірність"
    },
    "МАТЕМАТИКА В ІТ|Застосування теорії ймовірностей та математичної статистики в ІТ|Формула повної ймовірності. Формула Байєса. Схема незалежних випробувань Бернуллі. Закон великих чисел": {
      "question": "Яка формула використовується для обчислення ймовірності події A за умови, що сталася подія B, якщо відомі ймовірності P(B|A) та P(A)?",
      "options": [
        "Формула повної ймовірності.",
        "Формула великих чисел.",
        "Формула Байєса.",
        "Формула Бернуллі."
      ],
      "correct": 2,
      "explanation": "Формула Байєса використовується для обчислення ймовірності події A за умови, що сталася подія B, якщо відомі ймовірності P(B|A) та P(A). Вона є основним інструментом у байєсівській статистиці та дозволяє оновити ймовірність події на основі нової інформації.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування теорії ймовірностей та математичної статистики в ІТ",
      "topic": "Формула повної ймовірності. Формула Байєса. Схема незалежних випробувань Бернуллі. Закон великих чисел"
    },
    "МАТЕМАТИКА В ІТ|Застосування теорії ймовірностей та математичної статистики в ІТ|Числові характеристики одновимірних випадкових величин (математичне сподівання, середнє значення, медіана та дисперсія)": {
      "question": "Яка з наведених числових характеристик випадкової величини є мірою центральної тенденції та обчислюється як сума всіх значень, поділена на їх кількість?",
      "options": [
        "Дисперсія",
        "Математичне сподівання",
        "Стандартне відхилення",
        "Медіана"
      ],
      "correct": 1,
      "explanation": "Математичне сподівання є мірою центральної тенденції, яка обчислюється як середнє арифметичне всіх можливих значень випадкової величини. Воно показує 'очікуване' значення випадкової величини. Медіана також є мірою центральної тенденції, але вона є серединним значенням у відсортованому ряду даних. Дисперсія та стандартне відхилення є мірами розсіювання, а не центральної тенденції.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування теорії ймовірностей та математичної статистики в ІТ",
      "topic": "Числові характеристики одновимірних випадкових величин (математичне сподівання, середнє значення, медіана та дисперсія)"
    },
    "МАТЕМАТИКА В ІТ|Застосування теорії ймовірностей та математичної статистики в ІТ|Поняття розподілу випадкової величини. Функція розподілу. Щільність розподілу. Рівномірний та нормальний розподіли": {
      "question": "Яка з наведених функцій є функцією щільності ймовірності (PDF) для стандартного нормального розподілу?",
      "options": [
        "f(x) = (1/√(2π)) * e^(-x²/2)",
        "f(x) = 1/(b-a) для x ∈ [a, b]",
        "f(x) = 1/x для x > 0",
        "f(x) = λ * e^(-λx) для x ≥ 0"
      ],
      "correct": 0,
      "explanation": "Функція щільності ймовірності (PDF) стандартного нормального розподілу має вигляд f(x) = (1/√(2π)) * e^(-x²/2). Інші варіанти відповідають PDF рівномірного розподілу (варіант Б), експоненційного розподілу (варіант В) та не є коректною функцією щільності (варіант Г).",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування теорії ймовірностей та математичної статистики в ІТ",
      "topic": "Поняття розподілу випадкової величини. Функція розподілу. Щільність розподілу. Рівномірний та нормальний розподіли"
    },
    "МАТЕМАТИКА В ІТ|Застосування теорії ймовірностей та математичної статистики в ІТ|Поняття статистичного зв'язку. Лінійна і логістична регресія. Коефіцієнт парної кореляції": {
      "question": "Який коефіцієнт використовується для вимірювання сили та напряму лінійного зв'язку між двома змінними?",
      "options": [
        "Коефіцієнт регресії (β)",
        "Коефіцієнт варіації (CV)",
        "Коефіцієнт парної кореляції (r)",
        "Коефіцієнт детермінації (R²)"
      ],
      "correct": 2,
      "explanation": "Коефіцієнт парної кореляції (r) вимірює силу та напрям лінійного зв'язку між двома змінними. Він може набувати значень від -1 до 1, де 1 означає сильний прямий зв'язок, -1 – сильний обернений зв'язок, а 0 – відсутність лінійного зв'язку. R² вимірює частку дисперсії залежної змінної, поясненої незалежною змінною, а β – це параметр у рівнянні регресії. CV використовується для порівняння розкиду даних.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування теорії ймовірностей та математичної статистики в ІТ",
      "topic": "Поняття статистичного зв'язку. Лінійна і логістична регресія. Коефіцієнт парної кореляції"
    },
    "МАТЕМАТИКА В ІТ|Застосування теорії ймовірностей та математичної статистики в ІТ|Багатовимірні дискретні величини. Поняття про сумісний розподіл. Кореляційна матриця": {
      "question": "Що таке маргінальний розподіл у контексті багатовимірних дискретних величин?",
      "options": [
        "Розподіл, який визначає ймовірність кожної комбінації значень випадкових величин.",
        "Розподіл, що описує лише незалежні випадкові величини.",
        "Розподіл однієї з випадкових величин, отриманий шляхом підсумовування сумісного розподілу за всіма значеннями інших величин.",
        "Розподіл, що визначає залежність між двома випадковими величинами."
      ],
      "correct": 2,
      "explanation": "Маргінальний розподіл — це розподіл однієї з випадкових величин у багатовимірному розподілі, який отримують шляхом підсумовування сумісного розподілу за всіма можливими значеннями інших величин. Він показує ймовірність кожної окремої величини без урахування інших.",
      "difficulty": "A",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування теорії ймовірностей та математичної статистики в ІТ",
      "topic": "Багатовимірні дискретні величини. Поняття про сумісний розподіл. Кореляційна матриця"
    },
    "МАТЕМАТИКА В ІТ|Застосування теорії ймовірностей та математичної статистики в ІТ|Поняття випадкової функції та випадкового процесу": {
      "question": "Що таке стаціонарний випадковий процес?",
      "options": [
        "Процес, у якого кореляційна функція залежить лише від різниці моментів часу.",
        "Процес, у якого середнє значення дорівнює нулю.",
        "Процес, у якого статистичні характеристики не залежать від часу.",
        "Процес, у якого дисперсія зростає з часом."
      ],
      "correct": 2,
      "explanation": "Стаціонарний випадковий процес — це процес, у якого статистичні характеристики (такі як математичне сподівання, дисперсія, кореляційна функція) не змінюються з часом. Це означає, що його властивості є інваріантними відносно зсуву часу.",
      "difficulty": "A",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування теорії ймовірностей та математичної статистики в ІТ",
      "topic": "Поняття випадкової функції та випадкового процесу"
    },
    "МАТЕМАТИКА В ІТ|Застосування теорії ймовірностей та математичної статистики в ІТ|Основні задачі математичної статистики. Первинна обробка даних": {
      "question": "Який метод первинної обробки даних використовується для виявлення та усунення значень, що значно відхиляються від решти даних?",
      "options": [
        "Нормалізація.",
        "Стандартизація.",
        "Виявлення викидів.",
        "Дискретизація."
      ],
      "correct": 2,
      "explanation": "Виявлення викидів - це метод, який дозволяє ідентифікувати значення, що значно відрізняються від інших даних у наборі. Ці значення можуть бути результатом помилок у зборі даних або справжніми, але рідкісними подіями. Виявлення та обробка викидів є важливим етапом підготовки даних для подальшого аналізу.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування теорії ймовірностей та математичної статистики в ІТ",
      "topic": "Основні задачі математичної статистики. Первинна обробка даних"
    },
    "МАТЕМАТИКА В ІТ|Застосування теорії ймовірностей та математичної статистики в ІТ|Візуалізація даних (точкова діаграма, гістограма, стовпчаста діаграма, кругова діаграма)": {
      "question": "У вас є набір даних, що містить інформацію про кількість відвідувачів веб-сайту протягом року, розподілену по місяцях. Ви хочете візуалізувати загальну тенденцію зміни кількості відвідувачів протягом року. Який тип діаграми найкраще підійде для цієї мети?",
      "options": [
        "Стовпчаста діаграма",
        "Гістограма",
        "Кругова діаграма",
        "Точкова діаграма"
      ],
      "correct": 0,
      "explanation": "Стовпчаста діаграма є найкращим вибором для відображення тенденцій у часових рядах, оскільки вона дозволяє легко порівнювати значення між періодами (місяцями) та візуалізувати загальну динаміку. Точкова діаграма більше підходить для аналізу взаємозв'язків між двома змінними, гістограма — для відображення розподілу даних, а кругова діаграма — для показу часток у цілому.",
      "difficulty": "C",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування теорії ймовірностей та математичної статистики в ІТ",
      "topic": "Візуалізація даних (точкова діаграма, гістограма, стовпчаста діаграма, кругова діаграма)"
    },
    "МАТЕМАТИКА В ІТ|Застосування теорії ймовірностей та математичної статистики в ІТ|Точкові та інтервальні оцінки характеристик випадкових величин. Довірчі інтервали": {
      "question": "Що характеризує довірчий інтервал у статистичних оцінках?",
      "options": [
        "Діапазон значень, у якому з певною ймовірністю міститься істинне значення параметра.",
        "Точкове значення параметра, отримане за вибіркою.",
        "Середнє квадратичне відхилення вибірки.",
        "Максимальну похибку оцінювання без урахування ймовірності."
      ],
      "correct": 0,
      "explanation": "Довірчий інтервал — це діапазон значень, який з певним рівнем довіри (наприклад, 95%) містить істинне значення параметра генеральної сукупності. Він враховує як похибку оцінювання, так і ймовірність, на відміну від точкової оцінки, яка дає лише одне значення.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування теорії ймовірностей та математичної статистики в ІТ",
      "topic": "Точкові та інтервальні оцінки характеристик випадкових величин. Довірчі інтервали"
    },
    "МАТЕМАТИКА В ІТ|Застосування теорії ймовірностей та математичної статистики в ІТ|Основні поняття та перевірка статистичних гіпотез (нульова гіпотеза, альтернативна гіпотеза, рівень значущості, однорідність нормально розподілених вибірок)": {
      "question": "Яке значення p-value свідчить про те, що нульову гіпотезу можна відхилити на рівні значущості α = 0.05?",
      "options": [
        "p-value ≤ 0.5",
        "p-value < 0.05",
        "p-value = 0.05",
        "p-value > 0.05"
      ],
      "correct": 1,
      "explanation": "p-value (ймовірнісне значення) — це ймовірність отримання результатів, принаймні таких же екстремальних, як і спостережувані, за умови істинності нульової гіпотези. Якщо p-value менше обраного рівня значущості α (у цьому випадку 0.05), це свідчить про статистичну значущість результатів, і нульову гіпотезу можна відхилити.",
      "difficulty": "B",
      "section": "МАТЕМАТИКА В ІТ",
      "subsection": "Застосування теорії ймовірностей та математичної статистики в ІТ",
      "topic": "Основні поняття та перевірка статистичних гіпотез (нульова гіпотеза, альтернативна гіпотеза, рівень значущості, однорідність нормально розподілених вибірок)"
    },
    "МЕРЕЖІ ТА ОБМІН ДАНИМИ|Класифікація та функції комп'ютерних мереж|Комутація каналів і комутація пакетів. Топології комп'ютерних мереж": {
      "question": "Яка з перелічених характеристик є основною відмінністю комутації каналів від комутації пакетів?",
      "options": [
        "Комутація пакетів гарантує фіксовану затримку передачі даних.",
        "Комутація пакетів вимагає попереднього резервування ресурсів мережі.",
        "Комутація каналів забезпечує виділення фіксованого шляху на весь час сеансу зв'язку.",
        "Комутація каналів ефективніша при нерівномірному навантаженні мережі."
      ],
      "correct": 2,
      "explanation": "Основна відмінність комутації каналів полягає в тому, що вона виділяє фіксований шлях (канал) між вузлами на весь час сеансу зв'язку, навіть якщо канал не використовується активно. Це протиставляється комутації пакетів, де дані передаються окремими пакетами, які можуть йти різними маршрутами і не вимагають попереднього резервування ресурсів.",
      "difficulty": "B",
      "section": "МЕРЕЖІ ТА ОБМІН ДАНИМИ",
      "subsection": "Класифікація та функції комп'ютерних мереж",
      "topic": "Комутація каналів і комутація пакетів. Топології комп'ютерних мереж"
    },
    "МЕРЕЖІ ТА ОБМІН ДАНИМИ|Протоколи та моделі мереж|Поняття протоколу та інтерфейсу, ієрархія протоколів, потік інформації в мережі. Еталонні моделі ISO/OSI та TCP/IP": {
      "question": "Який рівень моделі OSI відповідає за маршрутизацію пакетів у мережі?",
      "options": [
        "Транспортний",
        "Фізичний",
        "Канальний",
        "Мережевий"
      ],
      "correct": 3,
      "explanation": "Мережевий рівень (рівень 3) моделі OSI відповідає за маршрутизацію пакетів, визначення оптимальних шляхів для передачі даних між вузлами в різних мережах. На цьому рівні працюють такі протоколи, як IP (Internet Protocol).",
      "difficulty": "B",
      "section": "МЕРЕЖІ ТА ОБМІН ДАНИМИ",
      "subsection": "Протоколи та моделі мереж",
      "topic": "Поняття протоколу та інтерфейсу, ієрархія протоколів, потік інформації в мережі. Еталонні моделі ISO/OSI та TCP/IP"
    },
    "МЕРЕЖІ ТА ОБМІН ДАНИМИ|Інтернет речей|основні поняття, сфери застосування": {
      "question": "Що є ключовою характеристикою M2M комунікації в IoT?",
      "options": [
        "Підключення пристроїв до інтернету через Wi-Fi.",
        "Використання хмарних сервісів для зберігання даних.",
        "Застосування штучного інтелекту для аналізу даних.",
        "Обмін даними між пристроями без прямої участі людини."
      ],
      "correct": 3,
      "explanation": "M2M (Machine-to-Machine) комунікація передбачає автоматизований обмін даними між пристроями без участі людини. Це основа IoT, де пристрої самостійно збирають, передають та обробляють інформацію (наприклад, сенсори в розумних містах або Industry 4.0). Інші варіанти є частинами IoT, але не визначають саме M2M.",
      "difficulty": "B",
      "section": "МЕРЕЖІ ТА ОБМІН ДАНИМИ",
      "subsection": "Інтернет речей",
      "topic": "основні поняття, сфери застосування"
    },
    "ОПЕРАЦІЙНІ СИСТЕМИ|Призначення операційних систем|Різновиди операційних систем (однокористувацькі, багатокористувацькі, реального часу)": {
      "question": "Яка з перелічених операційних систем є багатокористувацькою та належить до систем реального часу (RTOS)?",
      "options": [
        "Windows 10",
        "macOS",
        "Ubuntu Desktop",
        "FreeRTOS"
      ],
      "correct": 3,
      "explanation": "FreeRTOS є операційною системою реального часу (RTOS) і підтримує багатокористувацький режим. Windows 10, macOS та Ubuntu Desktop є загального призначення і не належать до RTOS, хоча Ubuntu може працювати у багатокористувацькому режимі.",
      "difficulty": "B",
      "section": "ОПЕРАЦІЙНІ СИСТЕМИ",
      "subsection": "Призначення операційних систем",
      "topic": "Різновиди операційних систем (однокористувацькі, багатокористувацькі, реального часу)"
    },
    "ОПЕРАЦІЙНІ СИСТЕМИ|Призначення операційних систем|Основні функції операційних систем": {
      "question": "Яка з наведених функцій є основною для операційної системи?",
      "options": [
        "Програмування мікропроцесорів",
        "Розробка мережевих протоколів",
        "Управління процесами",
        "Створення графічних інтерфейсів"
      ],
      "correct": 2,
      "explanation": "Управління процесами є однією з основних функцій операційної системи, оскільки вона забезпечує виконання, планування та синхронізацію роботи різних процесів. Інші варіанти стосуються більш спеціалізованих задач, які не є основними функціями ОС.",
      "difficulty": "A",
      "section": "ОПЕРАЦІЙНІ СИСТЕМИ",
      "subsection": "Призначення операційних систем",
      "topic": "Основні функції операційних систем"
    },
    "ОПЕРАЦІЙНІ СИСТЕМИ|Призначення операційних систем|Вимоги до операційних систем, поняття відмовостійкості": {
      "question": "Яка з наведених характеристик найкраще описує поняття відмовостійкості операційної системи?",
      "options": [
        "Кількість підтримуваних апаратних платформ.",
        "Здатність системи продовжувати роботу після виникнення помилок.",
        "Рівень захищеності від зовнішніх атак.",
        "Максимальна швидкість обробки даних системою."
      ],
      "correct": 1,
      "explanation": "Відмовостійкість — це здатність операційної системи продовжувати функціонування навіть у разі виникнення помилок або збоїв. Це досягається за рахунок механізмів відновлення, резервування та інших методів забезпечення надійності. Інші варіанти стосуються продуктивності, сумісності та безпеки, але не відмовостійкості.",
      "difficulty": "B",
      "section": "ОПЕРАЦІЙНІ СИСТЕМИ",
      "subsection": "Призначення операційних систем",
      "topic": "Вимоги до операційних систем, поняття відмовостійкості"
    },
    "ОПЕРАЦІЙНІ СИСТЕМИ|Файлові системи|Основні поняття про файли і файлові системи": {
      "question": "Який атрибут файлу визначає, чи може користувач змінювати вміст файлу?",
      "options": [
        "Атрибут 'тільки для читання'",
        "Атрибут 'прихований'",
        "Атрибут 'системний'",
        "Атрибут 'архівний'"
      ],
      "correct": 0,
      "explanation": "Атрибут 'тільки для читання' (read-only) забороняє зміну вмісту файлу. Якщо цей атрибут встановлений, користувач може лише читати файл, але не редагувати або видаляти його. Інші атрибути ('системний', 'прихований', 'архівний') не впливають на дозволи зміни вмісту.",
      "difficulty": "B",
      "section": "ОПЕРАЦІЙНІ СИСТЕМИ",
      "subsection": "Файлові системи",
      "topic": "Основні поняття про файли і файлові системи"
    },
    "ОПЕРАЦІЙНІ СИСТЕМИ|Файлові системи|Логічна та фізична організація файлів": {
      "question": "Яка файлова система використовує індексні дескриптори (inode) для керування файлами та каталогами?",
      "options": [
        "ext4",
        "exFAT",
        "FAT32",
        "NTFS"
      ],
      "correct": 0,
      "explanation": "Файлова система ext4, як і її попередники (ext2, ext3), використовує індексні дескриптори (inode) для зберігання метаданих файлів та каталогів, таких як права доступу, власник, розмір та розташування даних на диску. FAT32 та exFAT не використовують inode, а NTFS використовує інший механізм — Master File Table (MFT).",
      "difficulty": "B",
      "section": "ОПЕРАЦІЙНІ СИСТЕМИ",
      "subsection": "Файлові системи",
      "topic": "Логічна та фізична організація файлів"
    },
    "ОСНОВИ МОВ ПРОГРАМУВАННЯ|Сутність і види мов програмування|Поняття класу та об'єкта в об'єктно-орієнтованому програмуванні; конструктор і деструктор, інтерфейс і реалізація": {
      "question": "Що таке конструктор класу в об'єктно-орієнтованому програмуванні?",
      "options": [
        "Метод, який автоматично викликається при створенні об'єкта та ініціалізує його стан.",
        "Функція, яка видаляє об'єкт з пам'яті після завершення його життєвого циклу.",
        "Інтерфейс, що визначає набір методів для взаємодії з об'єктом.",
        "Шаблон, який описує структуру даних об'єкта без реалізації."
      ],
      "correct": 0,
      "explanation": "Конструктор — це спеціальний метод класу, який викликається при створенні нового об'єкта. Він відповідає за ініціалізацію полів об'єкта та забезпечення його коректного початкового стану. На відміну від деструктора, який звільняє ресурси, конструктор 'готує' об'єкт до використання.",
      "difficulty": "B",
      "section": "ОСНОВИ МОВ ПРОГРАМУВАННЯ",
      "subsection": "Сутність і види мов програмування",
      "topic": "Поняття класу та об'єкта в об'єктно-орієнтованому програмуванні; конструктор і деструктор, інтерфейс і реалізація"
    },
    "ОСНОВИ МОВ ПРОГРАМУВАННЯ|Сутність і види мов програмування|Базові концепції об'єктно-орієнтованого програмування: абстракція, інкапсуляція, спадкування, поліморфізм": {
      "question": "Який принцип об'єктно-орієнтованого програмування дозволяє приховувати внутрішню реалізацію класу та надавати доступ до даних лише через публічні методи?",
      "options": [
        "Інкапсуляція",
        "Абстракція",
        "Поліморфізм",
        "Спадкування"
      ],
      "correct": 0,
      "explanation": "Інкапсуляція — це принцип ООП, який дозволяє приховувати внутрішній стан об'єкта та обмежувати доступ до нього, надаючи публічні методи для взаємодії. Це забезпечує контроль над зміною даних і запобігає прямому доступу до внутрішніх полів класу.",
      "difficulty": "B",
      "section": "ОСНОВИ МОВ ПРОГРАМУВАННЯ",
      "subsection": "Сутність і види мов програмування",
      "topic": "Базові концепції об'єктно-орієнтованого програмування: абстракція, інкапсуляція, спадкування, поліморфізм"
    },
    "ОСНОВИ МОВ ПРОГРАМУВАННЯ|Сутність і види мов програмування|Зв'язки між класами в об'єктно-орієнтованому програмуванні: асоціація, агрегація, композиція, спадкування, залежність, реалізація": {
      "question": "У програмі для моделювання бібліотеки створено класи `Book` (Книга) та `Library` (Бібліотека). Клас `Library` містить список об'єктів `Book`, які можна додавати та видаляти незалежно від існування бібліотеки. Який тип зв'язку між класами `Library` та `Book` найкраще описує цю ситуацію?",
      "options": [
        "Композиція (об'єкти `Book` не можуть існувати без об'єкта `Library`)",
        "Спадкування (клас `Library` успадковує властивості класу `Book`)",
        "Агрегація (об'єкти `Book` можуть існувати незалежно від об'єкта `Library`)",
        "Асоціація (немає прямого зв'язку між класами `Library` та `Book`)"
      ],
      "correct": 2,
      "explanation": "Агрегація — це тип зв'язку, коли один клас (`Library`) містить інші об'єкти (`Book`), але ці об'єкти можуть існувати незалежно. У цьому випадку книги можуть бути частиною бібліотеки, але їхнє існування не залежить від бібліотеки (їх можна видалити або перенести до іншої бібліотеки). Це відрізняється від композиції, де об'єкти не можуть існувати окремо від контейнера.",
      "difficulty": "C",
      "section": "ОСНОВИ МОВ ПРОГРАМУВАННЯ",
      "subsection": "Сутність і види мов програмування",
      "topic": "Зв'язки між класами в об'єктно-орієнтованому програмуванні: асоціація, агрегація, композиція, спадкування, залежність, реалізація"
    },
    "ОСНОВИ МОВ ПРОГРАМУВАННЯ|Сутність і види мов програмування|Порівняння процедурного та об'єктно-орієнтованого програмування": {
      "question": "Яка з наведених характеристик є перевагою об'єктно-орієнтованого програмування (ООП) порівняно з процедурним програмуванням?",
      "options": [
        "Більш висока швидкість виконання програм.",
        "Менша кількість рядків коду для однакових задач.",
        "Можливість повторного використання коду через механізм успадкування.",
        "Відсутність необхідності в документації."
      ],
      "correct": 2,
      "explanation": "Основною перевагою ООП є можливість повторного використання коду завдяки механізмам успадкування, інкапсуляції та поліморфізму. Це дозволяє ефективніше керувати складними проектами та зменшувати дублювання коду. Інші варіанти не є точними: швидкість виконання залежить від багатьох факторів, кількість рядків коду не завжди менша, а документація завжди необхідна.",
      "difficulty": "B",
      "section": "ОСНОВИ МОВ ПРОГРАМУВАННЯ",
      "subsection": "Сутність і види мов програмування",
      "topic": "Порівняння процедурного та об'єктно-орієнтованого програмування"
    },
    "ОСНОВИ МОВ ПРОГРАМУВАННЯ|Парадигми програмування|Принципи та сфера застосування видів програмування: функціональне, логічне, подійно-орієнтоване, реактивне, узагальнене програмування": {
      "question": "Яка з наведених характеристик є ключовою для функціонального програмування?",
      "options": [
        "Застосування шаблонів для узагальненого коду",
        "Використання логічних правил для виведення результатів",
        "Immutability (незмінність даних)",
        "Використання подій для керування потоком виконання"
      ],
      "correct": 2,
      "explanation": "Immutability (незмінність даних) є однією з основних характеристик функціонального програмування. Вона передбачає, що дані не змінюються після їх створення, що сприяє відсутності побічних ефектів та полегшує тестування та відлагодження коду. Інші варіанти відносяться до інших парадигм: подійно-орієнтоване (події), узагальнене програмування (шаблони) та логічне програмування (логічні правила).",
      "difficulty": "B",
      "section": "ОСНОВИ МОВ ПРОГРАМУВАННЯ",
      "subsection": "Парадигми програмування",
      "topic": "Принципи та сфера застосування видів програмування: функціональне, логічне, подійно-орієнтоване, реактивне, узагальнене програмування"
    },
    "ОСНОВИ МОВ ПРОГРАМУВАННЯ|Моделі паралельних обчислень|класифікація Флінна": {
      "question": "Яка архітектура з класифікації Флінна передбачає одночасне виконання однієї інструкції над різними даними?",
      "options": [
        "SISD",
        "SIMD",
        "MIMD",
        "MISD"
      ],
      "correct": 1,
      "explanation": "Архітектура SIMD (Single Instruction, Multiple Data) передбачає одночасне виконання однієї інструкції над різними даними. Це типова модель для векторних процесорів та сучасних графічних процесорів (GPU), де одна команда застосовується до багатьох елементів даних одночасно.",
      "difficulty": "B",
      "section": "ОСНОВИ МОВ ПРОГРАМУВАННЯ",
      "subsection": "Моделі паралельних обчислень",
      "topic": "класифікація Флінна"
    },
    "ОСНОВИ МОВ ПРОГРАМУВАННЯ|Трансляція та виконання|компілятор, інтерпретатор, компонувальник": {
      "question": "Яка основна відмінність між компілятором та інтерпретатором?",
      "options": [
        "Компілятор працює тільки з мовами низького рівня, а інтерпретатор — з мовами високого рівня.",
        "Компілятор вимагає наявності компонувальника, а інтерпретатор — ні.",
        "Компілятор виконує код рядок за рядком, а інтерпретатор перетворює весь вихідний код у машинний код перед виконанням.",
        "Компілятор перетворює весь вихідний код у машинний код перед виконанням, а інтерпретатор виконує код рядок за рядком."
      ],
      "correct": 3,
      "explanation": "Компілятор аналізує та перетворює весь вихідний код програми в машинний код (або проміжне представлення) перед її виконанням, що дозволяє оптимізувати програму та виявити помилки на ранніх етапах. Інтерпретатор же виконує код рядок за рядком, що робить процес виконання повільнішим, але дозволяє швидше отримувати результат під час розробки.",
      "difficulty": "B",
      "section": "ОСНОВИ МОВ ПРОГРАМУВАННЯ",
      "subsection": "Трансляція та виконання",
      "topic": "компілятор, інтерпретатор, компонувальник"
    },
    "ШТУЧНИЙ ІНТЕЛЕКТ|Фундаментальні поняття|інтелектуальна система, агент, середовище, задачі штучного інтелекту, сильний і слабкий штучний інтелект": {
      "question": "Що описує PEAS модель у контексті раціональних агентів?",
      "options": [
        "Модель, що описує процес навчання агента через підкріплення.",
        "Модель, що визначає лише внутрішній стан агента без урахування середовища.",
        "Модель, що визначає продуктивність, середовище, актуатори та сенсори агента.",
        "Модель, що описує виключно комунікацію між агентами."
      ],
      "correct": 2,
      "explanation": "PEAS модель (Performance, Environment, Actuators, Sensors) використовується для опису раціональних агентів. Вона визначає: продуктивність (критерії успіху агента), середовище (умови, в яких агент діє), актуатори (засоби впливу агента на середовище) та сенсори (засоби сприйняття агента). Це фундаментальна модель для проектування інтелектуальних систем.",
      "difficulty": "B",
      "section": "ШТУЧНИЙ ІНТЕЛЕКТ",
      "subsection": "Фундаментальні поняття",
      "topic": "інтелектуальна система, агент, середовище, задачі штучного інтелекту, сильний і слабкий штучний інтелект"
    },
    "ШТУЧНИЙ ІНТЕЛЕКТ|Пошук у просторі станів та подання знань|Стратегії пошуку у просторі станів: пошук вшир, пошук вглиб, прямий, зворотний та двонаправлений пошук": {
      "question": "Яка з наведених стратегій пошуку у просторі станів гарантовано знаходить найкоротший шлях у незваженому графі?",
      "options": [
        "Зворотний пошук",
        "Пошук вшир (BFS)",
        "Пошук вглиб (DFS)",
        "Прямий пошук"
      ],
      "correct": 1,
      "explanation": "Пошук вшир (BFS) гарантовано знаходить найкоротший шлях у незваженому графі, оскільки він досліджує всі вершини на поточному рівні перед переходом на наступний рівень. Це забезпечує, що перше знаходження цільової вершини буде за найменшою кількістю кроків.",
      "difficulty": "B",
      "section": "ШТУЧНИЙ ІНТЕЛЕКТ",
      "subsection": "Пошук у просторі станів та подання знань",
      "topic": "Стратегії пошуку у просторі станів: пошук вшир, пошук вглиб, прямий, зворотний та двонаправлений пошук"
    },
    "ШТУЧНИЙ ІНТЕЛЕКТ|Пошук у просторі станів та подання знань|Моделі подання знань (семантична мережа, продукційна модель)": {
      "question": "Яка модель подання знань використовує вузли для представлення понять та зв'язки між ними для відображення відношень?",
      "options": [
        "Продукційна модель",
        "Семантична мережа",
        "Фреймова модель",
        "Логічна модель"
      ],
      "correct": 1,
      "explanation": "Семантична мережа — це модель подання знань, яка використовує вузли для представлення понять (об'єктів, подій, категорій) та зв'язки (ребра) між ними для відображення відношень (наприклад, «є частиною», «є підкласом»). Це графічний спосіб організації знань, що дозволяє візуалізувати структуру інформації та робити логічні висновки.",
      "difficulty": "B",
      "section": "ШТУЧНИЙ ІНТЕЛЕКТ",
      "subsection": "Пошук у просторі станів та подання знань",
      "topic": "Моделі подання знань (семантична мережа, продукційна модель)"
    },
    "ШТУЧНИЙ ІНТЕЛЕКТ|Машинне навчання|Задача класифікації. Навчання з вчителем та без учителя": {
      "question": "Яка основна відмінність між навчанням з учителем (supervised learning) та навчанням без учителя (unsupervised learning)?",
      "options": [
        "Навчання з учителем застосовується лише для класифікації, а навчання без учителя – для регресії.",
        "Навчання з учителем використовує мічені дані, а навчання без учителя – ні.",
        "Навчання з учителем завжди дає точніші результати, ніж навчання без учителя.",
        "Навчання без учителя вимагає більше обчислювальних ресурсів, ніж навчання з учителем."
      ],
      "correct": 1,
      "explanation": "Основна відмінність полягає у використанні мічених даних. У навчанні з учителем алгоритм навчається на даних, де кожен приклад має відповідну мітку (наприклад, клас або числове значення). У навчанні без учителя дані не мічені, і алгоритм має самостійно виявляти структуру або закономірності (наприклад, кластеризація). Інші варіанти є неправильними, оскільки: (2) навчання з учителем може використовуватися і для регресії; (3) обчислювальні витрати залежать від конкретного алгоритму, а не типу навчання; (4) точність залежить від задачі та даних, а не типу навчання.",
      "difficulty": "B",
      "section": "ШТУЧНИЙ ІНТЕЛЕКТ",
      "subsection": "Машинне навчання",
      "topic": "Задача класифікації. Навчання з вчителем та без учителя"
    },
    "ШТУЧНИЙ ІНТЕЛЕКТ|Машинне навчання|Вибір тренувальних та валідаційних даних для навчання": {
      "question": "Яка основна мета розділення даних на тренувальний та валідаційний набори при навчанні моделі машинного навчання?",
      "options": [
        "Для прискорення процесу навчання моделі.",
        "Для зменшення кількості параметрів моделі.",
        "Для зменшення обсягу даних, необхідних для навчання моделі.",
        "Для оцінки якості моделі на незалежних даних та запобігання перенавчанню."
      ],
      "correct": 3,
      "explanation": "Розділення даних на тренувальний та валідаційний набори дозволяє оцінити, наскільки добре модель узагальнює дані, які вона не бачила під час навчання. Це допомагає виявити перенавчання (overfitting), коли модель демонструє високу точність на тренувальних даних, але погано працює на нових даних.",
      "difficulty": "B",
      "section": "ШТУЧНИЙ ІНТЕЛЕКТ",
      "subsection": "Машинне навчання",
      "topic": "Вибір тренувальних та валідаційних даних для навчання"
    },
    "ШТУЧНИЙ ІНТЕЛЕКТ|Машинне навчання|Поняття: штучний нейрон, штучна нейронна мережа, функції активації штучного нейрона (лінійна, порогова, сигмоїдна, радіально-базисна Гауса)": {
      "question": "Яка з наведених функцій активації найчастіше використовується у прихованих шарах глибоких нейронних мереж через її властивість усувати проблему зникаючого градієнта?",
      "options": [
        "Сигмоїдна (sigmoid)",
        "Гіперболічний тангенс (tanh)",
        "Лінійна (linear)",
        "Виправлений лінійний одиничний (ReLU)"
      ],
      "correct": 3,
      "explanation": "Функція активації ReLU (Rectified Linear Unit) є найпоширенішим вибором для прихованих шарів глибоких нейронних мереж, оскільки вона не пригнічує градієнт для додатних вхідних значень, що допомагає уникнути проблеми зникаючого градієнта. На відміну від сигмоїди та tanh, які можуть призводити до дуже малих градієнтів під час навчання, ReLU забезпечує ефективніше навчання глибоких мереж.",
      "difficulty": "B",
      "section": "ШТУЧНИЙ ІНТЕЛЕКТ",
      "subsection": "Машинне навчання",
      "topic": "Поняття: штучний нейрон, штучна нейронна мережа, функції активації штучного нейрона (лінійна, порогова, сигмоїдна, радіально-базисна Гауса)"
    }
  }
}